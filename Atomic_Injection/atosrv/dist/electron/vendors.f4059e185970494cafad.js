(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{1515:function(e,t,s){"use strict";var i=s(28),a=s.n(i),r=s(22),n=s(31),o=s(3);t.a=class Reviews{constructor(){this.settings=o.q,this.fetcher=null,this.fetchSettings()}async fetchSettings(){clearTimeout(this.fetcher);try{this.settings=await n.a.get("review-settings")}catch(e){console.error("Fetch cashback settings failed:",e)}this.fetcher=setTimeout(this.fetchSettings,6e5)}async sendReview({atomicId:e,email:t,rating:s,operatingSystem:i,appVersion:n,platform:o,text:c,subject:d}){await a.a.post("https://atomic-reviews.atomicwallet.io/conversation",{atomicId:e,email:t,rating:s,operatingSystem:i,appVersion:n,platform:o,text:c,subject:d}).catch(e=>{r.a.error({instance:this,error:e})})}}},1517:function(e,t,s){"use strict";var i=s(28),a=s.n(i),r=s(4),n=s(20),o=s(3);t.a=class SimplexDb{async getSimplexTransactionsFromDb(){return await n.e.simplexTxs.toArray()}async getSimplexTransactionsFromNet(e){const t={url:"https://apollo.atomicwallet.io/simplex/buy/user",params:{atomicId:e},method:"get"},{data:s}=await a()(t).catch(e=>{throw new r.e({type:o.e,error:e,instance:this})}),i=s.map(e=>({id:e.paymentId,quoteId:e.quoteId,userId:e.atomicId,status:e.status,txHash:e.payoutHash,payinHash:e.payinHash,payoutHash:e.payoutHash,refundAddress:e.refundAddress,payoutAddress:e.payoutAddress,payinAddress:e.payinAddress,payinExtraId:e.payinExtraId,fromCurrency:e.fromCurrency,toCurrency:e.toCurrency,amountToSend:e.amountSend,amountToReceive:e.amountReceive,expectedCashbackAmount:e.Cashbacks.length>0?e.Cashbacks[0].expectedCashbackAmount:"0",timestamp:e.createdAt}));return await this._insertBatch(i),i}async addSimplexTransactionToDb(e){return await n.e.simplexTxs.add(e),e}postCashbackBuyTx(e){const t={url:"https://apollo.atomicwallet.io/simplex/buy",data:e,method:"post"};return a()(t)}async _insertBatch(e){return await n.e.simplexTxs.bulkPut(e),e}}},1529:function(e,t,s){"use strict";var i=s(371),a=s.n(i);t.a=class SecureStorage{constructor(e,t){this.password=t,this.storage=e}decode(e,t){if(!t)throw new Error("No password");return a.a.AES.decrypt(e.toString(),t).toString(a.a.enc.Utf8)}encode(e,t){if(!t)throw new Error("No password");return a.a.AES.encrypt(e,String(t))}exists(e){return new Promise((t,s)=>{this.getItemWrap(e,e=>{t("null"!==e)},s)})}get(e){return new Promise((t,s)=>{this.getItemWrap(e,e=>{"null"===e&&s(new Error("Wrong password!"));try{e=this.decode(e,this.password)}catch(e){s(e)}t(e)},s)})}getItemWrap(e,t,s){this.storage.getItem(e,t,i=>{("function"!=typeof this.storage.getString||i&&5!==i.code)&&s(i),this.storage.getString(e,t,s)})}set(e,t){return new Promise((s,i)=>{this.storage.setItem(e,this.encode(t,this.password).toString(),s,i)})}remove(e){return new Promise((t,s)=>{this.storage.remove(e,t,s)})}checkPassword(e){return new Promise((t,s)=>{this.storage.getItem("general_mnemonic",i=>{"null"===i&&s(new Error("No mnemonic"));try{const a=this.decode(i,e);a||s(new Error("Wrong password!")),t(a)}catch(e){s(e)}},s)})}getByPassword(e,t){return new Promise((s,i)=>{this.storage.getItem(e,e=>{"null"===e&&i(new Error("Wrong password!"));try{s(this.decode(e,t))}catch(e){i(e)}},i)})}getAllByPassword(e,t){return Promise.all(e.map(async e=>await this.getByPassword(e,t)))}changePassword(e,t){return new Promise((s,i)=>{e&&t||i(new Error("No password set!")),this.getAllByPassword(["general_mnemonic","wallets"],e).then(([e,i])=>{this.password=t,this.set("general_mnemonic",e),this.set("wallets",i),s()}).catch(()=>{i(new Error("Wrong password"))})})}}},1614:function(e,t,s){"use strict";var i={};s.r(i),s.d(i,"BANDStaking",(function(){return o})),s.d(i,"ATOMStaking",(function(){return c})),s.d(i,"XTZStaking",(function(){return d})),s.d(i,"TRXStaking",(function(){return h})),s.d(i,"ICXStaking",(function(){return l})),s.d(i,"ADAStaking",(function(){return u})),s.d(i,"ZILStaking",(function(){return p})),s.d(i,"SOLStaking",(function(){return m})),s.d(i,"NEARStaking",(function(){return g}));var a=s(28),r=s.n(a),n=s(104);class BANDStaking_BANDStaking extends n.a{constructor(){super(),this.name="BAND"}async fetchActiveValidators(){}modifyActiveValidators(e){const t=this.validators.map(({name:e})=>e),s=e.map(({description:e})=>e.moniker);t.forEach(e=>{s.includes(e)||this.validators.splice(this.validators.findIndex(t=>t.name===e),1)})}}var o=BANDStaking_BANDStaking;class ATOMStaking_ATOMStaking extends n.a{constructor(){super(),this.name="ATOM"}async fetchActiveValidators(){}modifyActiveValidators(e){const t=this.validators.map(({name:e})=>e),s=e.map(({description:e})=>e.moniker);t.forEach(e=>{s.includes(e)||this.validators.splice(this.validators.findIndex(t=>t.name===e),1)})}}var c=ATOMStaking_ATOMStaking;class XTZStaking_XTZStaking extends n.a{constructor(){super(),this.name="XTZ"}async fetchActiveValidators(){}}var d=XTZStaking_XTZStaking;class TRXStaking_TRXStaking extends n.a{constructor(){super(),this.name="TRX"}async fetchActiveValidators(){}}var h=TRXStaking_TRXStaking;class ICXStaking_ICXStaking extends n.a{constructor(){super(),this.name="ICX"}async fetchActiveValidators(){}}var l=ICXStaking_ICXStaking;class ADAStaking_ADAStaking extends n.a{constructor(){super(),this.name="ADA"}async fetchActiveValidators(){}}var u=ADAStaking_ADAStaking;class ZILStaking_ZILStaking extends n.a{constructor(){super(),this.name="ZIL"}async fetchActiveValidators(){}}var p=ZILStaking_ZILStaking;class SOLStaking_SOLStaking extends n.a{constructor(){super(),this.name="SOL"}async fetchActiveValidators(){}}var m=SOLStaking_SOLStaking;class NEARStaking_NEARStaking extends n.a{constructor(){super(),this.name="NEAR"}async fetchActiveValidators(){}}var g=NEARStaking_NEARStaking,f=s(31),y=s(22),w=s(73),b=s(217),v=s(1722),k=s(3),T=s(890);const A={BAND:"stake_validators_band",ATOM:"stake_validators_atom-2",XTZ:"stake_validators_tezos",TRX:"stake_validators_trx",ICX:"stake_validators_icx",ZIL:"stake_validators_zil",ADA:"stake_validators_ada",SOL:"stake_validators_sol",NEAR:"stake_validators_near"};t.a=class Stakings_Stakings extends Array{constructor(...e){super(...e);Object.keys(i).forEach(e=>{this.push(new i[e])}),this.settings=k.u,this.fetchPredefinedValidators()}async fetchSettings(){let e;try{e=await f.a.get("staking-coins-list")}catch(e){y.a.error({instance:this,error:e})}const t=e||k.u;return this.settings=t.filter(({platforms:e=null})=>!!e&&e.filter(e=>{const t=Object(T.a)(w.a.getPlatform(),e);return!Number.isNaN(e)&&t-Object(T.a)(w.a.getPlatform(),w.a.getVersion())<=0}).length>0),this.settings}fetchPredefinedValidators(){Object.keys(A).forEach(async e=>{let t;try{t=await f.a.get(A[e])}catch(e){y.a.error({instance:this,error:e})}if(t)return this.savePredefinedValidators(e,t);const s=b.find(t=>t.currency===e);return this.savePredefinedValidators(e,s.validators)})}savePredefinedValidators(e,t){const s=this.getStakingInterface(e);if(s){if("XTZ"===e){const e=t.filter(e=>e.stakingCapacity>e.stakingBalance);return void s.modifyPredefinedValidators(e)}s.modifyPredefinedValidators(t)}}getStakingInterface(e){return this.find(t=>t.getName().toLowerCase()===e.toLowerCase())}saveSuccessStaking(e){const t={method:"post",url:"https://apollo.atomicwallet.io/stakings",data:e};v.a.submitEverstakeTx({provider:e.provider,currency:e.currency,hash:e.hash}),r()(t)}}},1621:function(e,t,s){"use strict";var i=s(28),a=s.n(i),r=s(1440),n=s.n(r),o=s(655),c=s(380),d=s.n(c),h=s(139),l=s(31),u=s(155),p=s(472),m=s(4),g=s(87),f=s(22),y=s(1448),w=s(73),b=s(886),v=s(620),k=s.n(v),T=s(151),A=s(3);const _=process.env.WATCHER_ENDPOINT||"https://subsync.atomicwallet.io";var x=class Socket_Socket{constructor(e,t){this.user=e,this.endpoint=t||"https://zeus.atomicwallet.io",this.socket=k()(this.endpoint,{transports:["websocket"]}),this.subs=null,this.socket.on("connect",()=>{this.subscribe()}),this.socket.on("disconnect",()=>{this.socket.connect()})}subscribe(){this.socket.emit("subscribe",this.user);const e={jsonrpc:"2.0",method:"subscribe",params:[{user_id:this.user.id,app_id:"atomicwallet"},this.user.addresses],id:1};a.a.post(_+"/rpc",e).catch(e=>console.warn(e)),this.listen()}listen(){this.subs=A.v.map(e=>(this.socket.off(e),this.socket.on(e,t=>{T.a.emit(e,t)})))}},S=s(394),C=s(29),B=s(20),P=s(1721),N=s(89),K=s(9);const L={nft:6e4};let I;class Wallets_Wallets extends Array{constructor(...e){super(...e),this.store={walletsCollection:{atomic:new Map}},this.BitcoreMnemonic=n.a,this.logger=f.a,this.socket=null,this.autoUpdateBalances=!0,this.autoUpdateTransactions=!0,this.autoUpdateCoinsDataCounter=null,this.autoUpdateBalancesCounter=null,this.autoUpdateTransactionsCounter=null,this.autoUpdateNftTimeouts={},this.disabledSockets=!1,this.updateProcessFlag=!1}static getInstance(...e){return I=Wallets_Wallets.getConfig(),new Wallets_Wallets(...e)}findToken({contract:e,parent:t,ticker:s}){return this.getTokens().find(({contract:i,parent:a,ticker:r})=>r.toUpperCase()===s.toUpperCase()&&(i&&i.toLowerCase()===(null==e?void 0:e.toLowerCase())||"eth"!==t&&(null==t?void 0:t.toLowerCase())===(null==a?void 0:a.toLowerCase())))}static async getConfig(){try{return l.a.get("wallets_fee_8")}catch(e){throw new m.j({type:A.x,error:e,instance:this})}}getTokens(){return Array.from(this).filter(e=>e instanceof S.a)}async initialize(){let e;try{e=await I}catch(t){e=y}const t=new P.a(Object(B.b)(e,"className"),e=>(this.push(e),this.store.walletsCollection[e.alias].set(e.id.toUpperCase(),e),e.install(this),"function"==typeof e.loadTokensList?e.loadTokensList(this):Promise.resolve("no tokens found")));try{await t.installAsync(),t.installStaticallyLoadedCoins(),await t.installTokens()}catch(e){f.a.error({instance:this,error:e})}finally{this.initCoinDataUpdate()}}isWalletActive(e){var t;return h.b.isActive(e,null===(t=this.getWallet(e.parent))||void 0===t?void 0:t.address)}setActivityChecked(e,t,s){!h.b.getCheckResult(e,t)&&(e instanceof u.a||s)&&h.b.setChecked(e,t,s);[h.a.balance,h.a.history].every(t=>h.b.isChecked(e,t))&&!this.isWalletActive(e)&&"function"==typeof e.disconnectSocket&&e.disconnectSocket()}setAutoUpdateBalances(e=!0){this.autoUpdateBalances=e}setAutoUpdateTransactions(e=!0){this.autoUpdateTransactions=e}async initCoinDataUpdate(){clearTimeout(this.autoUpdateCoinsDataCounter),await this.updateCoinsData().catch(()=>({})),this.autoUpdateCoinsDataCounter=setTimeout(()=>{this.initCoinDataUpdate()},3e5)}async updateCoinsData(){(await Wallets_Wallets.getConfig()).forEach(async e=>{const t=e.className.match(/(Coin|Token)/)[1],s=e.className.replace(t,""),i=s&&this.findWallet(s)||null,r=e.feesEstimateUrl;if("Coin"===t)try{if(i&&"BTC"===i.ticker&&r){const t=await a.a.get(r).catch(e=>console.warn("Bitcoinfees is unavailable",e));t&&t.data&&t.data.fastestFee&&(e.feeData.feePerByte=t.data.fastestFee)}i&&"function"==typeof i.updateCoinParamsFromServer&&i.updateCoinParamsFromServer(e)}catch(e){f.a.error({instance:this,error:new Error(`${s}: ${e.message}`)})}if("Token"===t)try{(i?Object.keys(i.tokens):[]).forEach(t=>{i.tokens[t].updateTokenParamsFromServer(e)})}catch(e){f.a.error({instance:this,error:new Error(`${s}: ${e.message}`)})}})}get hash(){return d()(d()(this.mnemonic.toString()))}validateMnemonic(e){return this.BitcoreMnemonic.isValid(e)}async loadWalletsByMnemonic(e,t={},s=5){t.$bus.$emit(N.a.START_LOADING_ALL,this.length),this.phrase=e,this.mnemonic=new this.BitcoreMnemonic(e),this.emitNewAtomicId(this.hash),f.a.hash=this.hash;const i=this.mnemonic.toString();let a=0;this.seed=this.mnemonic.toSeed();const r=Array.from(this).map(e=>async()=>{e.transactions.length>0&&(e.transactions=[]),t.$bus.$emit(N.a.START_LOADING,e);try{await e.loadWallet(this.seed,i)}catch(s){throw t.$bus.$emit(N.a.RAISE_LOADING_ERROR,{wallet:e.name}),new m.j({type:A.x,error:s,instance:e})}t.$bus.$emit(N.a.UPDATE_LOADING_PROGRESS,{progress:++a}),t.$bus.$emit(N.a.FINISH_LOADING,e),"function"==typeof e.fetchUserTokens&&e.fetchUserTokens(this),e.setBus(t.$bus),await e.fakeThrow().catch(e=>console.warn(e))}),n=new b.a(r,s);await n.execute(),t.$bus.$emit(N.a.FINISH_LOADING_ALL),this.disabledSockets||this.enableSockets()}async loadWalletsByKeys(e,t,s,i=5){this.phrase=s;const a=e.filter(e=>e.privateKey),r=a.length,n=Array.from(this).filter(e=>{const t=(s=e.id,a.findIndex(({id:e,alias:t})=>s===e&&"atomic"===t));var s;return e instanceof u.a&&-1===t});if(f.a.hash=this.hash,this.emitNewAtomicId(this.hash),n.length>0){this.seed=this.BitcoreMnemonic(this.mnemonic.toString()).toSeed(),t.$emit(N.a.START_LOADING_ALL,n.length);let e=0;const a=n.map(i=>async()=>{t.$emit(N.a.START_LOADING,i);try{await i.loadWallet(this.seed,s)}catch(e){t.$emit(N.a.RAISE_LOADING_ERROR,{wallet:i.name})}t.$emit(N.a.UPDATE_LOADING_PROGRESS,{progress:++e}),t.$emit(N.a.FINISH_LOADING,i),i.setBus(t),"function"==typeof i.fetchUserTokens&&await i.fetchUserTokens(this)}),r=new b.a(a,i);await r.execute(),t.$emit(N.a.FINISH_LOADING_ALL)}for(let e=0;e<r;e+=1){const{id:i,address:r,privateKey:n}=a[e];if(!i)return;const o=this.getWallet(i);if((o||o instanceof u.a)&&(o.setBus(t),o instanceof u.a)){if(r?(o.setAddress(r),"EOS"!==o.ticker&&"HBAR"!==o.ticker||(o.activated=!0)):("EOS"!==o.ticker&&"HBAR"!==o.ticker||await o.loadWallet(this.seed,s),console.warn("loadWalletsByKeys",o.ticker,"does not have address")),n)try{o.setPrivateKey(n,s)}catch(e){await o.loadWallet(this.seed,s)}else await o.loadWallet(this.seed,s),console.warn("loadWalletsByKeys",o.ticker,"does not have privateKey");"function"==typeof o.fetchUserTokens&&o.fetchUserTokens(this)}}this.disabledSockets||this.enableSockets(),t.$emit("save::wallets"),t.$emit("save::mnemonic",this.mnemonic.toString())}async updateWalletNft(e){if(!e.address||!e.isNftSupported())return;clearTimeout(this.autoUpdateNftTimeouts[e.id]);try{const t=await e.getNftList();await p.a.set(e,t),e.bus&&e.bus.$emit("update::nft::list::wallet",{ticker:e.ticker,id:e.id})}catch(e){console.warn(e)}const t=L["nft"];this.autoUpdateNftTimeouts[e.id]=setTimeout(()=>this.updateWalletNft(e),t)}initUpdateNft(){let e=null;return Promise.allSettled(Array.from(this).map(t=>(e=t.bus,!this.autoUpdateNftTimeouts[t.id]&&this.updateWalletNft(t)))).then(t=>(e&&e.$emit("update::nft::all"),t))}stopUpdateNft(){Object.keys(this.autoUpdateNftTimeouts).forEach(e=>{clearTimeout(this.autoUpdateNftTimeouts[e]),delete this.autoUpdateNftTimeouts[e]})}async fetchTransactions(e,t){try{if(e.address||await e.loadWallet(this.seed,this.phrase),!e.address)throw new Error(e.id+" address is not set");return e.getTransactions({address:e.address,pageNum:t})}catch(e){return console.warn(e),[]}}async initUpdateTransactions(){if(clearTimeout(this.autoUpdateTransactionsCounter),!this.autoUpdateTransactions)return;const e=await this.getTransactions().catch(e=>console.warn(e));e&&(this.transactions=e),this.autoUpdateTransactionsCounter=setTimeout(()=>{this.initUpdateTransactions()},6e4)}initUpdateBalances(){clearTimeout(this.autoUpdateBalancesCounter),this.autoUpdateBalances&&B.h.waitForPermitted(B.a.INITIAL_BALANCES).then(()=>{const e=[];for(let t=0;t<this.length;t+=1){const s=this[t];if(this.isWalletActive(s))try{const t=s.getInfo();e.push(t),t.then(()=>{s.bus.$emit("update",{ticker:s.ticker,alias:s.alias,id:s.id}),this.setActivityChecked(s,h.a.balance,s.balance>0)}).catch(e=>console.warn(e))}catch(e){console.warn(`[updateBalancesCycle] ${this[t].ticker} update crashed:`,e)}}B.h.setAsCompleted(B.a.INITIAL_BALANCES),this.autoUpdateBalancesCounter=setTimeout(()=>{this.initUpdateBalances()},6e4)})}loadTransactions(e){const t=e.length;for(let s=0;s<t;s+=1){const t=e[s],i=t.walletid&&"undefined"!==t.walletid?this.getWallet(t.walletid):null;if(i){const e=t.otherSideAddress||t.recepient;h.b.setChecked(i,h.a.history,!0),this.transactions=[new C.a({ticker:i.ticker,parent:i.parent,name:i.name,walletid:i.id,explorer:t.explorer,txid:t.txid,txType:t.txType,direction:t.direction,otherSideAddress:e,amount:t.amount,datetime:new Date(Number(t.timestamp)),memo:t.memo||"",nonce:t.nonce,confirmations:Number(t.confirmations)||0,alias:i.alias,fee:t.fee||null,feeTicker:t.feeTicker||""})]}}}getSumBalance(e){return Array.from(this).reduce((t,s)=>t+Number(s.balance)*e.getRate(s.ticker),0)}findWallet(e,t="atomic",s){return[...this.store.walletsCollection[t].values()].find(({ticker:t,contract:i})=>t.toLowerCase()===(null==e?void 0:e.toLowerCase())&&(!s||(null==i?void 0:i.toLowerCase())===s.toLowerCase()))}findWalletV2({ticker:e="",alias:t="atomic",contract:s="",parentTicker:i=""}){const a=[...this.store.walletsCollection[t].values()].filter(t=>{var i;return t.ticker.toLowerCase()===(null==e?void 0:e.toLowerCase())&&(!s||(null===(i=t.contract)||void 0===i?void 0:i.toLowerCase())===s.toLowerCase())});return a.length>1&&i?a.find(({parent:e})=>e.toLowerCase()===i.toLowerCase()):a[0]}getWallet(e,t="atomic"){if(!e)throw new Error("The ticker/id ");return this.store.walletsCollection[t].get(e.toUpperCase())}get transactions(){const e=[];Array.from(this).forEach(t=>{e.push(t.transactions)});const t=[].concat.apply([],e.filter(Boolean));return Object(o.a)(t.filter(({datetime:e})=>!Number.isNaN(new Date(e).getTime()))).desc(e=>e.datetime)}set transactions(e){e.forEach(e=>{const t=e.walletid&&this.getWallet(e.walletid,e.alias);if(void 0!==t&&t.transactions)if(t.transactions.find(({txid:t})=>e.txid===t)){const s=t.transactions.findIndex(({txid:t})=>e.txid===t);t.transactions[s]=e}else t.transactions.push(e)})}removeTransaction(e){const t=this.transactions.find(({txid:t})=>t===e.txid);if(t){const s=this.getWallet(t.walletid),i=s.transactions.findIndex(({txid:s})=>e.txid===t.txid);i>=0&&s.transactions.splice(i,1)}}async getTransactionsByWallet(e,t=5){if(!this.isWalletActive(e))return[];const s=[],i=e.bus;let a,r=0;const n=e.getTxLimit(),c=new Set(["ETH","AVAX","BSC","THETA"]),d=e instanceof S.a&&c.has(e.parent)?this.getWallet(e.parent):e;do{a=await this.fetchTransactions(d,r++),await g.a.filterAndUpdateTransactions(a),a&&a.length>0&&s.push(...a),i&&i.$emit("update::wallet-transactions",{ticker:e.ticker,alias:e.alias})}while(a.length>=n&&r<t);this.setActivityChecked(e,h.a.history,s.length>0),i&&i.$emit("transactions::end-update");const l=await g.a.selectTransactions({ticker:e.ticker,walletid:e.id,alias:"atomic"}),u=null==l?void 0:l.filter(({amount:e})=>"0"!==e).sort((e,t)=>e.txType>t.txType?1:-1).sort((e,t)=>t.datetime.getTime()>e.datetime.getTime()?1:-1);return Object(o.a)(u||[]).desc(e=>e.datetime)}async getTransactions(){if(this.transactionsLoading)return console.error(new Error("Transactions history update is not yet finished, new request is canceled.")),null;this.transactionsLoading=!0,await B.h.waitForPermitted(B.a.INITIAL_TRANSACTIONS);const e=[],t=Array.from(this);let s=null;for(let i=t.length-1;i>=0;i-=1){const a=t[i],r=a.bus;if(this.isWalletActive(a)){r&&!s&&(s=r,s.$emit("transactions::start-update"));try{const t=await this.fetchTransactions(a);await g.a.filterAndUpdateTransactions(t),t&&t.length>0&&e.push(...t),this.setActivityChecked(a,h.a.history,t.length>0),r&&r.$emit("update::wallet-transactions",{ticker:a.ticker,alias:a.alias})}catch(e){console.warn(e)}}}return s&&s.$emit("transactions::end-update"),this.transactionsLoading=!1,B.h.setAsCompleted(B.a.INITIAL_TRANSACTIONS),Object(o.a)(e).desc(e=>e.datetime).filter(Boolean)}enableSockets(){const e={id:this.hash,addresses:Array.from(this).map(e=>e.socket&&e.address?{ticker:e.ticker,address:e.address,name:e.name,parent:e.parent,contract:e.contract}:null).filter(Boolean),platform:w.a.getPlatform(),appVersion:w.a.getVersion()};this.socket=new x(e),this.store.walletsCollection.atomic.forEach(e=>{e instanceof u.a&&"function"==typeof e.connectSocket&&this.isWalletActive(e)&&e.connectSocket()})}disableSockets(){this.store.walletsCollection.atomic.forEach(e=>{"function"==typeof e.disconnectSocket&&e.disconnectSocket()})}async updateBalances(){if(this.updateProcessFlag)return console.warn("Update is cancelled"),null;this.updateProcessFlag=!0,await B.h.waitForPermitted(B.a.INITIAL_BALANCES);const e=Array.from(this).filter(e=>e instanceof u.a);let t=null;const s=[];for(let t=0;t<e.length;t+=1){const i=e[t];if(this.isWalletActive(i)){const e=i.getInfo();s.push(e),e.then(()=>this.setActivityChecked(i,h.a.balance,i.balance>0))}}const i=await Promise.allSettled(s);return i.forEach((s,i)=>{"rejected"===s.status&&(e[i].divisibleBalance=null,e[i].balance=null);const a=e[i].bus;a&&(t||(t=a),a.$emit("update",{ticker:e[i].ticker,alias:e[i].alias,id:e[i].id}))}),this.updateProcessFlag=!1,t&&t.$emit("update::balances"),B.h.setAsCompleted(B.a.INITIAL_BALANCES),i}getHiddenWallets(){const e=[];return this.store.walletsCollection.atomic.forEach(t=>{!1!==t.visibility||t.isCustom||e.push(t)}),e}getTickers(e="atomic"){return Array.from(this.store.walletsCollection[e].entries()).map(([e,t])=>t.ticker)}emitNewAtomicId(e){K.r.emit(N.a.NEW_ATOMIC_ID,{atomicId:e})}}t.a=Wallets_Wallets},1632:function(e,t,s){"use strict";s.d(t,"a",(function(){return RewardCalculator}));var i=s(16),a=s.n(i),r=s(28),n=s.n(r);const{Zilliqa:o}=s(794);class RewardCalculator{constructor(e,t){this.baseUrl=e,this.zilliqa=new o(e),this.contract=this.zilliqa.contracts.at(t),this.jsonBody=e=>({id:"atomic",jsonrpc:"2.0",method:"GetSmartContractSubState",params:[t,...e]})}async getRewards(e,t){const s=await n.a.post(this.baseUrl,this.jsonBody(["last_withdraw_cycle_deleg",[t.toLowerCase()]])),i=await n.a.post(this.baseUrl,this.jsonBody(["lastrewardcycle",[]])),a=s.data.result,r=i.data.result,o=await this.getRewardCycleList(a,r,e,t),c=await this.combineBuffDirect(e,t,o),d=await this.getRewardNeedCycleList(a,r,e,t);return await this.calculateRewards(e,c,d)}async getRewardCycleList(e,t,s,i){if(null!==e&&void 0!==e.last_withdraw_cycle_deleg[i][s]){const e=Number.parseInt(t.lastrewardcycle),s=[];let i=1;for(;i<=e;i++)s.push(i);return s}return[]}async getRewardNeedCycleList(e,t,s,i){const a=t.lastrewardcycle;if(null===e)return[];const r=e.last_withdraw_cycle_deleg[i][s];return(await this.getRewardCycleList(e,t,s,i)).filter(e=>e>Number.parseInt(r)&&e<=Number.parseInt(a))}async combineBuffDirect(e,t,s){const i=new Map,r=await n.a.post(this.baseUrl,this.jsonBody(["direct_deposit_deleg",[t.toLowerCase(),e]])),o=await n.a.post(this.baseUrl,this.jsonBody(["buff_deposit_deleg",[t.toLowerCase(),e]])),c=await n.a.post(this.baseUrl,this.jsonBody(["deleg_stake_per_cycle",[t.toLowerCase(),e]])),d=r.data.result,h=o.data.result,l=c.data.result;let u=null,p=null,m=null;return null!==d&&(u=d.direct_deposit_deleg[t.toLowerCase()][e]),null!==h&&(p=h.buff_deposit_deleg[t.toLowerCase()][e]),null!==l&&(m=l.deleg_stake_per_cycle[t.toLowerCase()][e]),s.forEach(e=>{const t=e-1,s=e-2;let r=new a.a(0);null!==m&&void 0!==m[t.toString()]&&(r=new a.a(m[t.toString()]));let n=new a.a(0);null!==u&&void 0!==u[t.toString()]&&(n=new a.a(u[t.toString()]));let o=new a.a(0);null!==p&&void 0!==p[s.toString()]&&(o=new a.a(p[s.toString()]));let c=n.add(o);c=c.add(r);const d=i.get(t);if(void 0!==d){const t=c.add(d);i.set(e,t)}else i.set(e,c)}),i}async calculateRewards(e,t,s){let i=new a.a(0);const r=(await n.a.post(this.baseUrl,this.jsonBody(["stake_ssn_per_cycle",[e]]))).data.result;return null===r||s.forEach(s=>{const n=r.stake_ssn_per_cycle[e][s];if(void 0===n);else{const e=new a.a(n.arguments[1]),r=new a.a(n.arguments[0]),o=t.get(s);if(void 0!==o){const t=o.mul(e).div(r);i=i.add(t)}}}),i}}},29:function(e,t,s){"use strict";t.a=class Transaction{constructor(e){if("object"!=typeof e)throw new TypeError("Transaction: constructor arguments object must be used");if(arguments.length>1)throw new Error("Transaction: constructor accepts only 1 argument");if(e.alias||(e.alias="atomic"),!e.ticker)throw new Error("Transaction: must have ticker");if(!e.datetime)throw new Error("Transaction: must have datetime object");"string"==typeof e.datetime&&(e.datetime=new Date(e.datetime));for(const[t,s]of Object.entries(e))this[t]=s;e.timestamp||(this.timestamp=e.datetime.getTime()),this.date=this.getDate(),this.time=this.getTime()}getDateTime(){return new Date(Number(""+this.timestamp))}getDate(){return this.datetime.toDateString().slice(4)}getTime(){return this.datetime.toTimeString().slice(0,5)}getStatus(){return this.confirmations>1?{text:"Confirmed",color:"#06CE91"}:{text:"Pending"}}getHash(){return this.txid}static fromHistory(e){const t=new this(e);return t.direction="in"===e.direction,t.datetime=t.getDateTime(),t.otherSideAddress=e.recepient,t}}},314:function(e,t,s){"use strict";var i=s(31),a=s(22),r=s(392),n=s(20);const o=(e,t)=>(t.sort(),`${e}-${t.join(",")}`);const c=new class Rates{constructor(){this.cache={popular:{},other:{}},this.data={},this.dexRatesCache=null,this.popularCoins=[],this.ratesProviders={atomicRaki:new r.a,coinMarketCap:new r.b,cryptoCompare:new r.c},this.ratesSettings={popular:[{provider:"atomicRaki",ttlSec:60},{provider:"cryptoCompare",ttlSec:60}],other:[{provider:"coinMarketCap",ttlSec:180},{provider:"cryptoCompare",ttlSec:180}]},i.a.get("rates-list").then(e=>{var t;this.popularCoins=(null===(t=e.providers[e.enabledProviders].tickers)||void 0===t?void 0:t.split(","))||[]}).catch(e=>a.a.error({instance:this,error:e})),i.a.get("rates-settings").then(e=>{this.ratesSettings=e}).catch(e=>a.a.error({instance:this,error:e}))}async getRatesFromDb(e){return e?n.e.rates.where({fiat:e}).toArray():n.e.rates.toArray()}async updateRatesInDb(e){await this._insertBatch(e)}async getRatesFromNet(e,t,s){return(await Promise.all(Object.keys(this.ratesSettings).map(async i=>{let a=[],r=[];for(const[c,{provider:d,ttlSec:h}]of this.ratesSettings[i].entries()){var n;const l=e.filter(({ticker:e})=>this.popularCoins.includes(e)===("popular"===i)).concat(r);r=[];const u=o(d,l.map(({id:e})=>e));if(!s&&(null===(n=this.cache[i][u])||void 0===n?void 0:n.expired)>Date.now())return this.cache[i][u].data;const p=await this.fetchRates(l,t,i,d);if(p.fetched){const e=this.ratesProviders[d].getTargetTickersMap(l),t=[];for(const s of l){const i=p.data.find(({ticker:t})=>t===e[s.id])||{};i.rate>0?t.push(Object.assign({walletId:s.id},i)):r.push(s)}a=a.concat(t);const s=1e3;this.cache[i][u]={data:t,expired:Date.now()+h*s}}if(0===r.length||c===this.ratesSettings[i].length-1)return a}return console.error(`no rates fetched for ${i} coins`),[]}))).flat(1)}async fetchRates(e,t,s,i){try{return{fetched:!0,data:await this.ratesProviders[i].get(e,t)}}catch(e){return console.error(e),{fetched:!1}}}setRate({id:e},t,s){this.data[e]||(this.data[e]={}),this.data[e][t]=s}updateDataRate(e,t,s){this.data[e]||(this.data[e]={}),this.data[e][t]=s}async initRates(){(await this.getRatesFromDb()).forEach(({rate:e=0,change:t=0,supply:s=0,volume:i=0,marketCap:a=0,fiat:r,walletId:n})=>{const o={rate:e,change:t,supply:s,volume:i,marketCap:a};this.updateDataRate(n,r,o)})}async updateRates(){const e=Object.keys(this.data).map(e=>Object.keys(this.data[e]).map(t=>{const s=this.data[e][t]||{};return{id:t+e,fiat:t,walletId:e,timestamp:(new Date).getTime(),rate:s.rate||0,change:s.change||0,volume:s.volume||0,supply:s.supply||0,marketCap:s.marketCap||0}})).flat();await this.updateRatesInDb(e)}getRate({id:e},t){const s=this.data[e];return s&&s[t]}async getRates(e,t="USD",s=!1){await this.initRates();const i=await this.getRatesFromNet(e,t,s);return n.h.setAsCompleted(n.a.INITIAL_RATES),i.length>0&&(i.forEach(({walletId:e,...s})=>{this.updateDataRate(e,t,s)}),await this.updateRates()),this.data}convertToUSD(e,{id:t},s){return e&&t&&s&&Object.keys(this.data).includes(t)&&void 0!==this.data[t][s]?Number(e)*this.data[t][s.toUpperCase()].rate:0}getCoinPrice(e,t){return this.getRateField(e,t,"rate")}getChangeDay(e,t){return this.getRateField(e,t,"change")}getMarketCap(e,t){return this.getRateField(e,t,"marketCap")}getRateField({id:e},t,s){try{return this.data[e][t][s]}catch(e){return 0}}async _insertBatch(e){await n.e.rates.bulkPut(e)}async _update(e){const t=await n.e.rates.where({ticker:e.ticker.toUpperCase(),fiat:e.fiat.toUpperCase()}).first().catch(e=>a.a.error({instance:this,error:e}));if(null!=t&&t.id)return await n.e.rates.update(t.id,e),e}};t.a=c},383:function(e,t,s){"use strict";s.d(t,"a",(function(){return AdaLibApi_AdaLibApi})),s.d(t,"b",(function(){return I})),s.d(t,"c",(function(){return D}));var i=s(913),a=s.n(i),r=s(74),n=s.n(r),o=s(62),c=s.n(o),d=s(185),h=s.n(d),l=s(132);const u=[2147483648,2147483648],p=0,m=2;function g(){const e=new c.a(6);return{primaryTicker:"ADA",decimalPlaces:e,totalSupply:new c.a("45 000 000 000".replace(/ /g,""),10).times(new c.a(10).pow(e))}}const f=e=>2147483648+e;class AdaLibApi_HaskellShelleyTxSignRequest{constructor(e,t){this.cardano=t,this.signRequest=e}totalInput(e){const t=this.signRequest.unsignedTx.get_implicit_input().checked_add(this.signRequest.unsignedTx.get_explicit_input()),s=this.signRequest.changeAddr.map(e=>new c.a(e.value||new c.a(0))).reduce((e,t)=>e.plus(t),new c.a(0)),i=new c.a(t.to_str()).minus(s);return e?i.shiftedBy(-g().decimalPlaces.toNumber()):i}totalOutput(e){const t=this.signRequest.unsignedTx.get_explicit_output(),s=new c.a(t.to_str());return e?s.shiftedBy(-g().decimalPlaces.toNumber()):s}fee(e){const t=this.signRequest.unsignedTx.get_fee_or_calc(),s=new c.a(t.to_str());return e?s.shiftedBy(-g().decimalPlaces.toNumber()):s}receivers(e){const t=this.signRequest.unsignedTx.build().outputs(),s=[];for(let e=0;e<t.len();e+=1)s.push(this.toHexOrBase58(t.get(e).address()));if(!e){const e=this.signRequest.changeAddr.map(e=>e.address);return s.filter(t=>!e.includes(t))}return s}uniqueSenderAddresses(){return Array.from(new Set(this.signRequest.senderUtxos.map(e=>e.receiver)))}isEqual(e){return null!=e&&(e instanceof this.cardano.TransactionBuilder&&(t=this.signRequest.unsignedTx,s=e,Buffer.from(t.build().to_bytes()).toString("hex")===Buffer.from(s.build().to_bytes()).toString("hex")));var t,s}toHexOrBase58(e){const t=this.cardano.ByronAddress.from_address(e);return null==t?Buffer.from(e.to_bytes()).toString("hex"):t.to_base58()}self(){return this.signRequest}}class AdaLibApi_AdaLibApi{constructor(e,t,s){this.cardano=t,this.legacyLib=e,this.cip1852Account=void 0,this.legacyAccount=void 0,this.protocolParams={linearFee:this.cardano.LinearFee.new(this.cardano.BigNum.from_str(String(s.feeCoefficient)),this.cardano.BigNum.from_str(String(s.feeConst))),minimumUtxoVal:this.cardano.BigNum.from_str("1"),poolDeposit:this.cardano.BigNum.from_str("50000000"),keyDeposit:this.cardano.BigNum.from_str("2000000")},this.legacyCrypto={HDNode:({secret:e,secretKey:t,publicKey:s,chainCode:i})=>{e?(t=e.slice(0,64),s=e.slice(64,96),i=e.slice(96,128)):e=Buffer.concat([t,s,i]);const a=Buffer.concat([s,i],64);function r(){return Buffer.concat([t,a])}return{secretKey:t,publicKey:s,chainCode:i,extendedPublicKey:a,toBuffer:r,toString:function(){return r().toString("hex")}}},deriveChildHdNode:(e,t)=>{const s=h.a.derivePrivate(e.toBuffer(),t,1);return this.legacyCrypto.HDNode({secretKey:s.slice(0,64),publicKey:s.slice(64,96),chainCode:s.slice(96,128)})}}}getCip1852AccountFromMnemonic(e){const t=a.a.mnemonicToEntropy(e);return this.cardano.Bip32PrivateKey.from_bip39_entropy(Buffer.from(t,"hex"),Buffer.from("")).derive(f(1852)).derive(f(1815)).derive(f(0))}getCip1852AccountFromPrivateKey(e){return this.cip1852Account=this.cardano.Bip32PrivateKey.from_bech32(e),this.cip1852Account}getLegacyAccountFromMnemonic(e){const t=this.legacyLib.Entropy.from_english_mnemonics(e);return this.legacyAccount=this.legacyLib.DaedalusWallet.recover(t),this.legacyAccount}async getPrivateKeyByMnemonic(e){const t=this.getCip1852AccountFromMnemonic(e);return this.cip1852Account=t,t.to_bech32()}async getLegacyPrivateKeyByMnemonic(e){const t=await h.a.mnemonicToRootKeypair(e,1);return n.a.encode(t)}getLegacyAddressByPrivateKeySync(e){const{HDNode:HDNode,deriveChildHdNode:t}=this.legacyCrypto,s=HDNode({secret:n.a.decode(e)}),i=u.reduce(t,s).extendedPublicKey,a=this.getHDPassphrase(e);return h.a.packAddress(u,i,a,1)}getHDPassphrase(e){const t=n.a.decode(e),s=this.legacyCrypto.HDNode({secret:t});return Object(l.pbkdf2Sync)(s.extendedPublicKey,"address-hashing",500,32,"sha512")}async getAddressByPrivateKey(e){const t=e||this.cip1852Account,s=t.derive(p).derive(0).to_public(),i=t.derive(m).derive(0).to_public();return this.cardano.BaseAddress.new(1,this.cardano.StakeCredential.from_keyhash(s.to_raw_key().hash()),this.cardano.StakeCredential.from_keyhash(i.to_raw_key().hash())).to_address().to_bech32()}validateShelleyPrivateKey(e){try{return this.cardano.Bip32PrivateKey.from_bech32(e)}catch(e){return!1}}validateShelleyAddress(e){if(!e)return!1;try{return this.cardano.Address.from_bech32(e)}catch(e){return!1}}validateAddress(e){let t;if(!e)return!1;try{if(t=this.cardano.Address.from_bech32(e),t)return t}catch(e){t=!1}try{t=this.cardano.ByronAddress.from_base58(e)}catch(e){t=!1}return t}normalizeToAddress(e){return this.cardano.ByronAddress.is_valid(e)?this.cardano.ByronAddress.from_base58(e).to_address():this.cardano.Address.from_bech32(e)}newAdaUnsignedTx(e,t,s,i,a,r,n){const o=a+21600,c=new Map;for(const e of i)c.set({amount:e.amount,receiver:e.receiver,tx_hash:e.tx_hash,tx_index:e.tx_index,utxo_id:e.tx_hash+e.tx_index},e);const d=this.newAdaUnsignedTxFromUtxo(e,t,s,Array.from(c.keys()),this.protocolParams,o,r,n);return{senderUtxos:d.senderUtxos.map(e=>{const t=c.get(e);if(null==t)throw new Error("[newAdaUnsignedTx] utxo reference was changed. Should not happen");return t}),txBuilder:d.txBuilder,changeAddr:d.changeAddr}}findSuitableInputs(e=[],t){if(e.length<=0)throw new Error("[findSuitableInputs]: UTXOs must be provided");let s=new c.a(t);const i=new c.a(0),a=new c.a(-1),r=new c.a("1000000"),n=[],o=[...e.sort((e,t)=>Number(e.amount)-Number(t.amount))];let d=o.length-1;for(;(s.gt(i)||s.lt(i)&&s.times(a).lt(r))&&!(d<0);){const e=o.findIndex(e=>new c.a(e.amount).gte(s));e>=0?(s=s.minus(new c.a(o[e].amount)),n.push(...o.splice(e,1))):(s=s.minus(new c.a(o[d].amount)),n.push(...o.splice(d,1))),d=o.length-1}return n}newAdaUnsignedTxFromUtxo(e,t,s,i,a=this.protocolParams,r=21600,n,o){const d=this.normalizeToAddress(e);if(null==d)throw new Error("[newAdaUnsignedTxFromUtxo] receiver not a valid Shelley address");const h=this.cardano.TransactionBuilder.new(a.linearFee,a.minimumUtxoVal,a.poolDeposit,a.keyDeposit);h.set_ttl(r);const l=null===t&&n;l||null===t||h.add_output(this.cardano.TransactionOutput.new(d,this.cardano.BigNum.from_str(t))),n&&h.set_certs(n),o&&h.set_withdrawals(o);const u=l?new c.a(25e5):new c.a(h.get_explicit_output().checked_add(h.min_fee()).to_str()),p=this.findSuitableInputs(i,u,h);p.forEach(e=>{this.addUtxoInput(h,e)});const m=(()=>{if(null==s)return h.set_fee(h.min_fee()),[];const e=this.cardano.BigNum.from_str(u.toString()),t=this.normalizeToAddress(s);if(null==t)throw new Error("[newAdaUnsignedTxFromUtxo] change not a valid Shelley address");const i=new c.a(h.get_explicit_input().checked_sub(e).to_str());let a=!1;try{i.toNumber()>0&&(h.add_change_if_needed(t),a=!0)}catch(e){console.warn(e)}return a?[{address:s,value:i.toString()}]:[]})();return{senderUtxos:p,txBuilder:h,changeAddr:m}}addUtxoInput(e,t){const s=this.normalizeToAddress(t.receiver),i=this.getCardanoAddrKeyHash(s);if(null!==i){if(void 0===i)throw new Error("addUtxoInput script inputs not expected");e.add_key_input(i,this.utxoToTxInput(t),this.cardano.BigNum.from_str(t.amount))}else{const i=this.cardano.ByronAddress.from_address(s);if(null==i)throw new Error("Add input should never happen: non-byron address without key hash");e.add_bootstrap_input(i,this.utxoToTxInput(t),this.cardano.BigNum.from_str(t.amount))}}utxoToTxInput(e){return this.cardano.TransactionInput.new(this.cardano.TransactionHash.from_bytes(Buffer.from(e.tx_hash,"hex")),e.tx_index)}getCardanoAddrKeyHash(e){if(this.cardano.ByronAddress.from_address(e))return null;{const t=this.cardano.BaseAddress.from_address(e);if(t)return t.payment_cred().to_keyhash()}{const t=this.cardano.PointerAddress.from_address(e);if(t)return t.payment_cred().to_keyhash()}{const t=this.cardano.EnterpriseAddress.from_address(e);if(t)return t.payment_cred().to_keyhash()}{const t=this.cardano.RewardAddress.from_address(e);if(t)return t.payment_cred().to_keyhash()}throw new Error(" unknown address type")}signTransaction(e,t=this.cip1852Account){const s=new AdaLibApi_HaskellShelleyTxSignRequest({senderUtxos:e.senderUtxos,unsignedTx:e.txBuilder,changeAddr:e.changeAddr},this.cardano),i=this.legacyLib.DaedalusAddressChecker.new(this.legacyAccount);let a;const r=new Set,n=new Set,o=[];for(const t of e.senderUtxos){const e=this.normalizeToAddress(t.receiver);if(null==e)throw new Error("[signTransaction] utxo not a valid Shelley address");const s=this.getCardanoAddrKeyHash(e),i=Buffer.from(e.to_bytes()).toString("hex");if(null!==s){if(void 0===s)throw new Error("[signTransaction] cannot sign script inputs");{const e=Buffer.from(s.to_bytes()).toString("hex");n.has(e)||(n.add(e),o.push(t))}}else a=this.legacyLib.Address.from_base58(t.receiver),r.has(i)||(r.add(i),o.push(t))}const c=s.signRequest.unsignedTx instanceof this.cardano.TransactionBuilder?s.signRequest.unsignedTx.build():s.signRequest.unsignedTx,d={shelleyKey:t.derive(0).derive(0).to_raw_key(),shelleyStakeKey:t.derive(2).derive(0).to_raw_key()};a&&(d.byronKey=Buffer.from(i.check_address(a).private_key().to_hex(),"hex"));const h=this.addWitnesses({txBody:c,uniqueUtxo:o,keys:d});return{rawtx:this.cardano.Transaction.new(c,h).to_bytes(),txid:Buffer.from(this.cardano.hash_transaction(c).to_bytes()).toString("hex")}}addWitnesses({txBody:e,uniqueUtxo:t,keys:s}){const{byronKey:i,shelleyKey:a,shelleyStakeKey:r}=s,n=this.cardano.hash_transaction(e),o=this.cardano.BootstrapWitnesses.new(),c=this.cardano.Vkeywitnesses.new(),d=this.cardano.TransactionWitnessSet.new();for(let e=0;e<t.length;e+=1){const s=this.normalizeToAddress(t[e].receiver);if(null==s)throw new Error("[addWitnesses] utxo not a valid Shelley address");const d=this.cardano.ByronAddress.from_address(s);if(d){const e=this.cardano.make_daedalus_bootstrap_witness(n,d,this.cardano.LegacyDaedalusPrivateKey.from_bytes(i));o.add(e)}else{const e=this.cardano.make_vkey_witness(n,a),t=this.cardano.make_vkey_witness(n,r);c.add(e),c.add(t)}}return o.len()>0&&d.set_bootstraps(o),c.len()>0&&d.set_vkeys(c),d}estimateFee({address:e,amount:t,outputs:s,ttl:i,certs:a}){const r=this.cardano.TransactionBuilder.new(this.protocolParams.linearFee,this.protocolParams.minimumUtxoVal,this.protocolParams.poolDeposit,this.protocolParams.keyDeposit),n=this.normalizeToAddress(e);return r.add_output(this.cardano.TransactionOutput.new(n,this.cardano.BigNum.from_str(String(t)))),s.forEach(e=>{this.addUtxoInput(r,e)}),r.set_ttl(i+21600),a&&r.set_certs(a),r.min_fee().to_str()}createTransaction({address:e,amount:t,changeAddress:s,utxo:i,slotNo:a}){const r=this.newAdaUnsignedTx(e,t,s,i,a);return this.signTransaction(r)}createStakeRegistrationCertificate(e){const t=this.cardano.StakeRegistration.new(e);return this.cardano.Certificate.new_stake_registration(t)}createStakeDeregistrationCertificate(e){const t=this.cardano.StakeDeregistration.new(e);return this.cardano.Certificate.new_stake_deregistration(t)}createStakeDelegationCertificate(e,t){const s=this.cardano.StakeDelegation.new(e,t);return this.cardano.Certificate.new_stake_delegation(s)}createDelegationTransaction({paymentAddress:e,utxo:t,slotNo:s,poolId:i,stakeAddressRegistered:a}){const r=this.cardano.Address.from_bech32(e),n=this.cardano.BaseAddress.from_address(r),o=this.cardano.Certificates.new(),c=this.cardano.Ed25519KeyHash.from_bytes(Buffer.from(i,"hex"));a||o.add(this.createStakeRegistrationCertificate(n.stake_cred())),o.add(this.createStakeDelegationCertificate(n.stake_cred(),c));const d=this.newAdaUnsignedTx(e,null,e,t,s,o);return this.signTransaction(d)}getRewardAddressHexFromAddressStr(e){return Buffer.from(this.getRewardAddress(e).to_address().to_bytes()).toString("hex")}createWithdrawalTransaction({paymentAddress:e,utxo:t,slotNo:s,rewardAddress:i,amountToWithdraw:a}){const r=this.cardano.Withdrawals.new();r.insert(i,this.cardano.BigNum.from_str(a));const n=this.newAdaUnsignedTx(e,null,e,t,s,void 0,r);return this.signTransaction(n)}getRewardAddress(e){const t=this.cardano.Address.from_bech32(e),s=this.cardano.BaseAddress.from_address(t).stake_cred();return this.cardano.RewardAddress.new(1,s)}}var y=s(221),w=s.n(y),b=s(3),v=s(4);const k=[2147483648,2147483648];class AdaLibApi_legacy_CborIndefiniteLengthArray{constructor(e){this.elements=e}encodeCBOR(e){return e.push(Buffer.concat([Buffer.from([159]),...this.elements.map(e=>w.a.encode(e)),Buffer.from([255])]))}}function T(e,t,s){return Math.ceil(s+e*t)}function A({secret:e,secretKey:t,publicKey:s,chainCode:i}){e?(t=e.slice(0,64),s=e.slice(64,96),i=e.slice(96,128)):e=Buffer.concat([t,s,i]);const a=Buffer.concat([s,i],64);function r(){return Buffer.concat([t,a])}return{secretKey:t,publicKey:s,chainCode:i,extendedPublicKey:a,toBuffer:r,toString:function(){return r().toString("hex")}}}function _(e,t){const s=h.a.derivePrivate(e.toBuffer(),t,1);return A({secretKey:s.slice(0,64),publicKey:s.slice(64,96),chainCode:s.slice(96,128)})}async function x(e,t){const s=await S(t);return h.a.unpackAddress(e,s).derivationPath}function S(e){const t=A({secret:n.a.decode(e)});return Object(l.pbkdf2Sync)(t.extendedPublicKey,"address-hashing",500,32,"sha512")}async function C(e,t){const s=e.getId(),i=await Promise.all(e.inputs.map(async e=>{const i=await x(e.utxo.receiver,t),a=A({secret:n.a.decode(t)});return function(e,t){return{extendedPublicKey:e,signature:t,encodeCBOR:function(s){return s.pushAny([0,new w.a.Tagged(24,w.a.encode([e,t]))])}}}(i.reduce(_,a).extendedPublicKey,function(e,t,s){const i=t.reduce(_,s),a=Buffer.from(e,"hex");return h.a.sign(a,i.toBuffer())}("011a2d964a095820"+s,i,a))}));return function(e,t){return{getId:function(){return e.getId()},witnesses:t,txAux:e,encodeCBOR:function(s){return s.pushAny([e,t])}}}(e,i)}function B(e){const t=e.amount,s=e.tx_hash,i=e.tx_index;return{coins:t,txHash:s,outputIndex:i,utxo:e,encodeCBOR:function(e){return e.pushAny([0,new w.a.Tagged(24,w.a.encode([Buffer.from(s,"hex"),i]))])}}}function P(e,t,s){return{address:e,coins:t,isChange:s,encodeCBOR:function(s){return s.pushAny([N(e),t])}}}function N(e){return{address:e,encodeCBOR:function(t){return t.push(e)}}}function K(e,t,s,i){const a=w.a.encode(new AdaLibApi_legacy_CborIndefiniteLengthArray(e)).length,r=t.length;return 1+(1+a+(i?r+76+18+2:r+9+2)+1)+(142*e.length+1)+4}async function L(e){const t=[];for(let s=0;s<e.length;s+=1)t.push(B(e[s]));return t}var I={getDerivationPathFromAddress:x,getPrivateKeyByMnemonic:async function(e){const t=await h.a.mnemonicToRootKeypair(e,1);return n.a.encode(t)},getAddressByPrivateKey:function(e){const t=A({secret:n.a.decode(e)}),s=k.reduce(_,t).extendedPublicKey,i=S(e);return h.a.packAddress(k,s,i,1)},getTxFee:async function(e,t,s,i,a){const r=await L(e);return Math.ceil(function(e,t,s,i,a){if(s>Number.MAX_SAFE_INTEGER)throw new v.i({type:b.x,error:new Error("Unsupported amount of coins: "+s),instance:this});const r=e.reduce((e,t)=>e+t.coins,0),n=T(K(e,t,0,!1),i,a);if(s+n>=r)return n;const o=T(K(e,t,0,!0),i,a);if(s+o>r)return r-s;return o}(r,t,s,i,a))},prepareSignedTx:async function(e,t,s,i,a,r){return async function(e,t){const s=await C(e,t);return{txHash:s.getId(),txBody:w.a.encode(s).toString("hex"),cbor:w.a.encode(s)}}(await async function(e,t,s,i,a){const r=await L(e),n=r.reduce((e,t)=>e+Number(t.coins),0),o=n-i-Number(a);if(o<0)throw new v.i({type:b.x,error:new Error(`Transaction inputs (sum ${n}) don't cover coins (${i}) + fee (${a})`),instance:this});const c=[P(t,i,!1)];o>0&&c.push(P(s,o,!0));return function e(t,s,i){function a(){return h.a.blake2b(w.a.encode(e(t,s,i)),32).toString("hex")}return{getId:a,inputs:t,outputs:s,attributes:i,encodeCBOR:function(e){return e.pushAny([new AdaLibApi_legacy_CborIndefiniteLengthArray(t),new AdaLibApi_legacy_CborIndefiniteLengthArray(s),i])}}}(r,c,{})}(e,t,s,Number(i),r),a)},validateAddress:async function(e){if(!e)return!1;try{return h.a.isValidAddress(e)}catch(e){return!1}},getHDKey:function(e){const t=A({secret:n.a.decode(e)});return Object(l.pbkdf2Sync)(Buffer.concat([t.secretKey,t.chainCode]),"",4096,96,"sha512")}};var D={"cosmos-sdk/MsgSend":({fromAddress:e,toAddress:t,amount:s,fee:i,gas:a,memo:r,denom:n="uatom"})=>({msg:[{type:b.a.Send,value:{from_address:e,to_address:t,amount:[{denom:n,amount:s}]}}],fee:{amount:[{denom:n,amount:i}],gas:a},signatures:null,memo:r}),"cosmos-sdk/MsgDelegate":({delegatorAddress:e,validatorAddress:t,amount:s,fee:i,gas:a,memo:r,denom:n="uatom"})=>({msg:[{type:b.a.Delegate,value:{delegator_address:e,validator_address:t,amount:{denom:n,amount:s}}}],fee:{amount:[{denom:n,amount:i}],gas:a},signatures:null,memo:r}),"cosmos-sdk/MsgUndelegate":({delegatorAddress:e,validatorAddress:t,amount:s,fee:i,gas:a,memo:r="",denom:n="uatom"})=>({msg:[{type:b.a.Undelegate,value:{delegator_address:e,validator_address:t,amount:{denom:n,amount:s}}}],fee:{amount:[{denom:n,amount:i}],gas:a},signatures:null,memo:r}),"cosmos-sdk/MsgBeginRedelegate":({delegatorAddress:e,validatorSrcAddress:t,validatorDstAddress:s,amount:i,fee:a,gas:r,memo:n,denom:o="uatom"})=>({msg:[{type:b.a.Redelegate,value:{delegator_address:e,validator_src_address:t,validator_dst_address:s,amount:{denom:o,amount:i}}}],fee:{amount:[{denom:o,amount:a}],gas:r},signatures:null,memo:n})}},394:function(e,t,s){"use strict";var i=s(16),a=s.n(i),r=s(370),n=s.n(r),o=s(625),c=s(651),d=s(4),h=s(151);class Token extends(Object(c.a)(o.a)){constructor(...e){var t,s;super(...e),this.BN=a.a,this.bus=null,this.fields={},this.balance="",this.address="",this.transactions=[],this.isSetBalance=!1,this.fields.paymentId=!1,this.eventEmmiter=h.a,this.id=n.a.hash((null===(t=this.ticker)||void 0===t?void 0:t.toLowerCase())+(null===(s=this.contract)||void 0===s?void 0:s.toLowerCase())),this.config=e[8],this.manageEvents()}get args(){return{parent:String,name:String,ticker:String,decimal:Number,contract:String,uniqueField:String,isCustom:Boolean,visibility:Boolean}}get alias(){return"atomic"}get explorer(){return this.parent.explorer}async loadWallet(e){return this}getAddress(){return this.parent.address}async validateAddress(e){return this.parent.validateAddress(e,this.ticker)}async getInfo(){return{balance:this.balance,transactions:[]}}async getBalance(){return String(this.divisibleBalance)}async availableBalance(){return this.divisibleBalance?String(this.divisibleBalance):"0"}async isAvailableForFee(e,t){try{const s=e||await this.getFee();return new this.BN(t).gte(s)}catch(e){return!1}}async getFee(e=null,t=!1,s,i){throw new d.h("getFee",this)}async getTransactions(e,t){return this.transactions}async getTransaction(e){return this.parent.getTransaction(e)}updateTokenParamsFromServer(e){if(e.feeData){const t=t=>{void 0!==this[t]&&void 0!==e.feeData[t]&&(this[t]=e.feeData[t])};Object.keys(e.feeData).forEach(e=>{t(e)})}}isTagShown(){return new Set(["BNB","TRX","ETH","MATIC","BSC","LUNA"]).has(this.parent)}manageEvents(){this.eventEmmiter.on(`${this.parent}-${this.id}::new-socket-tx`,({unconfirmedTx:e})=>{this.eventEmmiter.emit(this.parent+"::new-token-tx",{token:this.contract,unconfirmedTx:e})})}}t.a=Token},469:function(e,t,s){"use strict";s.d(t,"j",(function(){return o})),s.d(t,"k",(function(){return l})),s.d(t,"i",(function(){return p})),s.d(t,"e",(function(){return f})),s.d(t,"l",(function(){return x})),s.d(t,"f",(function(){return N})),s.d(t,"d",(function(){return I})),s.d(t,"g",(function(){return E})),s.d(t,"a",(function(){return O})),s.d(t,"h",(function(){return $})),s.d(t,"b",(function(){return G})),s.d(t,"c",(function(){return j}));var i=s(889),a=s.n(i),r=s(4),n=s(3);var o=e=>class extends e{async loadWallet(e,t){const s=a.a.HDNode.fromSeedBuffer(e,a.a.bitcoin).derivePath(this.derivation),{keyPair:i}=s.derive(0);if(!i)throw new r.i({type:n.x,error:new Error("can't derive private key"),instance:this});return this.setPrivateKey(i.toWIF()),this}getAddress(){return this.account?this.account.address:new r.i({type:n.x,error:new Error("this.account is empty"),instance:this})}async validateAddress(e){if(!e)return!1;const t="NEO3"===this.id?"N":"A";return e[0]===t&&this.coreLib.wallet.isAddress(e)}async createTransaction({address:e,amount:t,asset:s}){s||(s=this.ticker),"GAS"===s.toUpperCase()&&(t=this.toCurrencyUnit(t,8));const i=await this.coreLib.api.makeIntent({[s.toUpperCase()]:t},e);return JSON.stringify(i)}async sendTransaction(e){const t=new this.coreLib.api.neoscan.instance("MainNet"),s=JSON.parse(e);try{const{response:{result:e,txid:i}}=await this.coreLib.default.sendAsset({api:t,account:this.account,intents:s});if(!e)throw new r.d({type:n.s,error:new Error("sendTransaction return false"),instance:this});return{txid:i}}catch(e){throw new r.d({type:n.s,error:e,instance:this})}}async getInfo(){const{balance:e,balances:t}=await this.explorer.getInfo(this.address);return this.balance=e,this.balances=t,{balance:e,balances:t}}async sendAllToMyself(){let e,t;this.balances.neo>0?(t="neo",e=this.balances.neo):this.balances.gas>0&&(t="gas",e=this.toMinimalUnit(this.balances.gas,8));const s=await this.createTransaction({address:this.address,amount:e,asset:t});return this.sendTransaction(s)}async claim(){try{if(!this.privateKey)throw new Error(`[${this.ticker}] claim: no private key`);await this.getInfo(this.address),await this.sendAllToMyself(),await new Promise((e,t)=>setTimeout(e,5e3));const e=new this.coreLib.api.neoscan.instance("MainNet");return{txid:(await this.coreLib.default.claimGas({api:e,account:this.account})).response.txid}}catch(e){throw new r.d({type:n.s,error:e,instance:this})}}async waitUntilConfirmed(e){let t=!1,s=0;do{try{await new Promise((e,t)=>setTimeout(e,5e3)),await this.getTransaction(e),t=!0}catch(e){if(s>=5)throw console.error(`[${this.ticker}] waitUntilConfirmed: max tries count reached`),e}s++}while(s<5&&!t)}get instance(){return{id:this.id,ticker:this.ticker,name:this.name,alias:this.alias,assetName:this.assetName,decimal:this.decimal,coreLib:this.coreLib,toCurrencyUnit:e=>this.toCurrencyUnit(e),toMinimalUnit:e=>this.toMinimalUnit(e),BN:this.BN}}async swap({amount:e,asset:t=this.ticker}){const{api:s,tx:i}=this.coreLib,{wallet:a}=this.coreLib3,r=this.account,n=s.makeIntent({[t]:e},"ANeo2toNeo3MigrationAddressxwPB2Hz"),o=new this.coreLib.api.neoscan.instance("MainNet"),c=await o.getBalance(r.address),d={url:o,account:r,balance:c,intents:n,fees:e>10?0:1,signingCallback:s.signWithPrivateKey(this.privateKey)},h=await s.createContractTx(d),l=new a.Account(this.privateKey);h.tx.addAttribute(i.TxAttrUsage.Remark14,Buffer.from(l.address).toString("hex")),await s.signTx(h);return{txid:(await s.sendTx(d)).response.txid}}setPrivateKey(e){this.privateKey=e,this.account=new this.coreLib.wallet.Account(e),this.address=this.account.address}},c=s(119),d=s(1633),h=s.n(d);var l=e=>class extends e{constructor(e){super(e),this.gasLimit=e&&e.feeData.gasLimit||"25000",this.gasPrice=e&&e.feeData.gasPrice||"3500"}async loadWallet(e,t){const s=c.Crypto.PrivateKey.generateFromMnemonic(t,this.derivation);if(!s)throw new Error(this.ticker+" can't get a privateKey!!!");const i=s.getPublicKey(),a=c.Crypto.Address.fromPubKey(i);return this.privateKey=s.serializeWIF(),this.address=a.toBase58(),this}getFee(){return new this.BN(this.gasLimit).mul(new this.BN(this.gasPrice))}getAddress(){if(this.privateKey){const e=this.getPrivateKeyObject().getPublicKey();return c.Crypto.Address.fromPubKey(e).toBase58()}throw new Error(this.ticker+" privateKey is empty!!!")}async validateAddress(e){if(!e)return!1;try{const{prefix:t}=h.a.decode(e,"hex");return t===c.CONST.ADDR_VERSION}catch(e){return!1}}async createTransaction({address:e,amount:t,asset:s}){s||(s=this.ticker);const i=this.getPrivateKeyObject(),a=new c.Crypto.Address(this.address),r=new c.Crypto.Address(e),n=c.OntAssetTxBuilder.makeTransferTx(s,a,r,Number(t),"3500","25000");return c.TransactionBuilder.signTransaction(n,i),n.serialize()}getPrivateKeyObject(){return c.Crypto.PrivateKey.deserializeWIF(this.privateKey)}async sendAllToMyself(e){const t=await this.createTransaction({address:this.address,amount:"ONT"===e?this.toMinimalUnit(this.balances.ont,0):this.toMinimalUnit(this.balances.ong,9),asset:e});return this.sendTransaction(t)}async checkUnbondSendTxAndRefreshBalance(){return this.balances.ont>0?await this.sendAllToMyself("ONT"):this.balances.ong>0&&await this.sendAllToMyself("ONG"),await new Promise(e=>setTimeout(e,5e3)),this.getInfo()}async checkRewardAndClaim(){const e=this.createClaimTransaction(this.balances.rewards);return this.sendTransaction(e)}async makeClaim(){const e=Number(this.balances.unbonding)+Number(this.balances.rewards);if(e<.03)throw new Error(`Unbonding + rewards ${e} ONG is less then 0.03 ONG`);if(Number(this.balances.ong)<=Number(this.fee))throw new Error(`${this.balances.ong} ONG is available, but needed ${this.fee} ONG to pay for fee`);return await this.checkUnbondSendTxAndRefreshBalance(),this.checkRewardAndClaim()}async getInfo(){const{balances:e}=await this.explorer.getInfo(this.address),t=this.ticker.toLowerCase();return e.available=e[t],this.balance=this.toMinimalUnit(e[t]),this.balances=e,{balance:this.balance,balances:this.balances}}createClaimTransaction(e){const t=new c.Crypto.Address(this.address),s=this.toMinimalUnit(e,9),i=c.OntAssetTxBuilder.makeWithdrawOngTx(t,t,s,t,"2500",""+c.CONST.DEFAULT_GAS_LIMIT),a=this.getPrivateKeyObject();return c.TransactionBuilder.signTransaction(i,a),i.serialize()}async claim(){try{if(!this.address)throw new Error("No coin address");if(this.balances||await this.getInfo(this.address),this.balances.rewards)return await this.makeClaim();throw new Error("No rewards")}catch(e){throw new r.d({type:"Send",error:e,instance:this})}}},u=s(39);var p=e=>class extends e{async createTransaction({address:e,amount:t,asset:s=this.ticker}){const i="NEO"===s?"NeoToken":"GasToken",a={from:this.account,to:e,integerAmt:Number(t),contractHash:this.coreLib.CONST.NATIVE_CONTRACT_HASH[i]},r=new this.coreLib.api.TransactionBuilder;r.addNep17Transfer(a.from,a.to,a.contractHash,a.integerAmt);const n=r.build(),o=await this.getProvider("node").getClient(),c=await this.coreLib.api.NetworkFacade.fromConfig({node:o});if(!(await c.validate(n)).valid)throw new Error("NEO: Unable to validate transaction");const d={signingCallback:this.coreLib.api.signWithAccount(this.account)};return c.sign(n,d)}async sendTransaction(e){return{txid:await this.getProvider("node").sendRawTransaction(e)}}async getInfo(){const{balance:e,balances:t}=await this.getProvider("balance").getInfo(this.address);return this.balance=this.toMinimalUnit(e||0),this.balances=t,{balance:e,balances:t}}get instance(){return{id:this.id,ticker:this.ticker,name:this.name,alias:this.alias,assetName:this.assetName,decimal:this.decimal,coreLib:this.coreLib,toCurrencyUnit:e=>this.toCurrencyUnit(e),toMinimalUnit:e=>this.toMinimalUnit(e)}}async getFee({sendAmount:e}){const[{feePerByte:t,executionFeeFactor:s},i]=await Promise.all([this.getProvider("node").getFeeInformation(this.coreLib.api),this.createTransaction({address:this.address,amount:e})]),a=this.coreLib.api.calculateNetworkFee(i,t,s);return Object(u.c)(a.toString(),8)}},m=s(16),g=s.n(m);var f=e=>class extends e{get instance(){return{id:this.id,ticker:this.ticker,name:this.name,decimal:this.decimal,alias:this.alias,parent:this.parent,BN:g.a,toCurrencyUnit:e=>this.toCurrencyUnit(e),toMinimalUnit:e=>this.toMinimalUnit(e),coreLibrary:this.coreLibrary,getAddressFromPublicKey:e=>this.getAddressFromPublicKey(e),getScriptPubKey:()=>this.coreLibrary.address.toOutputScript(this.address,this.network).toString("hex"),feeCoefficient:this.coefficient,feeDefault:this.feeData&&this.feeData.fee}}loadWallet(e){return new Promise((t,s)=>{const i=this.coreLibrary.HDNode.fromSeedBuffer(e,this.network).derivePath(this.derivation);i.keyPair||s(new r.i({type:n.x,error:new Error("can't get a privateKey!"),instance:this})),this.privateKey=i.keyPair.toWIF(),this.address=i.keyPair.getAddress(),t(this)})}getAddress(e=this.privateKey){return e?this.getKeyForSignFromPrivateKey(e).getAddress():new r.i({type:n.x,error:new Error("privateKey is empty!"),instance:this})}async validateAddress(e){if(!e)return!1;try{return this.coreLibrary.address.toOutputScript(e,this.network),!0}catch(e){return!1}}getTransactionBuilder(){return new this.coreLibrary.TransactionBuilder(this.network)}addInput(e,t){e.addInput(t.txId,t.outputIndex)}signInput(e,t,s,i){e.sign(s,t)}async createClaimTransaction(e){const t=this.getAddress(e);if(!t||0===t.length)throw new r.i({type:n.x,error:new Error("can't get a address from forked privateKey!"),instance:this});const s=await this.getUnspentOutputs(t);let i=this.explorer.calculateBalance(s);const a=await this.getFee(i,!0,t);if(i=new this.BN(i).sub(a).toString(),new this.BN(i).lt(new this.BN(0)))throw new r.f({type:n.s,error:new Error("Not enough otherside balance for claim"),instance:this});let o=new this.BN(0);const c=[],d=new this.BN(i).add(a);s.forEach(({txid:e,vout:t,address:s,script:i,value:a})=>{if(o.lt(d)){const r=new this.BN(a);o=o.add(r),c.push({txId:e,outputIndex:t,address:s,script:i,satoshis:parseInt(a,10)})}});const h=o.sub(new this.BN(i)).sub(a);if(h.lt(new this.BN(0)))throw new r.f({type:n.s,error:new Error("Insufficient funds!"),instance:this});return await this.buildTx(c,this.address,i,h,e,t)}async createTransaction({address:e,amount:t}){const s=await this.getUnspentOutputs(this.address,this.getScriptPubKey()),i=await this.getFee({amount:t});let a=new this.BN(0);const o=[],c=new this.BN(t).add(i);s.forEach(e=>{if(a.lt(c)){const t=new this.BN(e.value);a=a.add(t),o.push({txId:e.txid,outputIndex:e.vout,address:e.address,script:e.script,satoshis:parseInt(e.value,10)})}});const d=a.sub(new this.BN(t)).sub(i);if(d.lt(new this.BN(0)))throw new r.f({type:n.s,error:new Error("Insufficient funds!"),instance:this});return await this.buildTx(o,e,t,d)}buildTx(e,t,s,i,a,o){return new Promise((c,d)=>{const h=this.getTransactionBuilder();e.forEach(e=>{this.addInput(h,e)}),h.addOutput(t,parseInt(s.toString(),10)),i.gt(new this.BN(0))&&h.addOutput(o||this.address,parseInt(i.toString(),10));const l=this.getKeyForSignFromPrivateKey(a);e.forEach((e,t)=>{try{this.signInput(h,l,t,e)}catch(e){throw new r.d({type:n.s,error:e,instance:this})}});try{c(h.build().toHex())}catch(e){d(e)}})}getKeyForSignFromPrivateKey(e=this.privateKey){return this.coreLibrary.ECPair.fromWIF(e,this.network)}getScriptPubKey(){return this.coreLibrary.address.toOutputScript(this.address,this.network).toString("hex")}},y=s(180),w=s(118),b=s.n(w),v=s(186),k=s.n(v),T=(s(878),s(383));var A=s(31),_=s(217);var x=e=>class extends e{constructor(e){super(...arguments),this.predefinedValidators=[],this.balances={},this.getPredefinedValidators().then(e=>{this.predefinedValidators=e})}getStakingBalances(e){return this.getProvider("staking").getStakingBalances(e)}getUserValidators(e){return this.getProvider("staking").getUserValidators(e)}async getPredefinedValidators(){const e=await A.a.get(this.getPredefineValidatorsConfigName());return null!=e?e:this.getDefaultValidators()}getDefaultValidators(){var e;const t=_.find(({currency:e})=>e===this.ticker);return null!==(e=null==t?void 0:t.validators)&&void 0!==e?e:[]}getPredefineValidatorsConfigName(){return"stake_validators_"+this.ticker.toLowerCase()}},S=s(312),C=s(1634),B=s(1635),P=s(150);var N=e=>class extends e{async loadWallet(e,t){const s=y.bip32.fromSeed(e).derivePath(this.derivation);if(!s)throw new r.i({type:n.x,error:new Error("can't get a privateKey!"),instance:this});const i=y.crypto.hash160(s.publicKey);return this.privateKey=s.toWIF(),this.address=b.a.encode(this.prefix,b.a.toWords(i)),this.setPrivateKey(s.toWIF(),t),this}getAddress(){if(this.privateKey){const e=y.ECPair.fromWIF(this.privateKey),t=y.crypto.hash160(e.publicKey);return b.a.encode(this.prefix,b.a.toWords(t))}return new r.i({type:n.x,error:new Error("privateKey is empty!"),instance:this})}getSignKeys(){const e=y.ECPair.fromWIF(this.privateKey);return{privateKey:k.a.decode(this.privateKey).privateKey.toString("hex"),publicKey:e.publicKey.toString("hex")}}async validateAddress(e){try{const{prefix:t}=b.a.decode(e);return t===this.prefix}catch(e){return!1}}async getTransaction(e){return this.getProvider("history2").getTransaction(this.address,e)}async getTransactions({address:e=this.address,offset:t=0,limit:s=this.explorer.defaultTxLimit,pageNum:i=0}){return this.transactions=await this.getProvider("history2").getTransactions({address:e,offset:t,limit:s,pageNum:i,denom:this.denom}).catch(e=>{throw new r.d({type:n.i,error:e,instance:this})}),this.transactions}async getTransactionBlueprint({type:e,...t}){if(T.c[e])return T.c[e](t);if(e===n.a.Withdraw)return this.getProvider("send2").getTransactionRawardsBlueprint({from:this.address,...t});throw new Error(`[${this.ticker}] no ${e} tx blueprint found`)}async sign(e,t,s=""){this.signer=this.signer||await C.SigningStargateClient.offline(this.wallet);const i=await this.getProvider("send2").getSignerData(this.address);return this.signer.signDirect(this.address,e,t,s,i)}createTransaction({address:e,amount:t,memo:s=""}){const i=[{typeUrl:"/cosmos.bank.v1beta1.MsgSend",value:{fromAddress:this.address,toAddress:e,amount:[{denom:this.denom,amount:t}]}}],a={amount:[{denom:this.denom,amount:this.fee}],gas:this.sendFeeGas};return this.sign(i,a,s)}async sendTransaction(e){const t=B.TxRaw.encode(e).finish();return this.getProvider("send2").sendTransaction(t)}createDelegationTransaction(e,t,s=""){const i=[{typeUrl:"/cosmos.staking.v1beta1.MsgDelegate",value:{delegatorAddress:this.address,validatorAddress:e,amount:{denom:this.denom,amount:t}}}],a={amount:[{denom:this.denom,amount:this.fee}],gas:this.stakingFeeGas};return this.sign(i,a,s)}createRedelegationTransaction(e,t,s,i=""){const a=[{typeUrl:"/cosmos.staking.v1beta1.MsgBeginRedelegate",value:{delegatorAddress:this.address,validatorSrcAddress:e,validatorDstAddress:t,amount:{denom:this.denom,amount:s}}}],r={amount:[{denom:this.denom,amount:this.fee}],gas:this.stakingFeeGas};return this.sign(a,r)}createUnbondingDelegationTransaction(e,t){const s=[{typeUrl:"/cosmos.staking.v1beta1.MsgUndelegate",value:{delegatorAddress:this.address,validatorAddress:e,amount:{denom:this.denom,amount:t}}}],i={amount:[{denom:this.denom,amount:this.fee}],gas:this.stakingFeeGas};return this.sign(s,i)}async createWithdrawDelegationTransaction(e){const t=(await this.getProvider("balance2").getValidators(this.address)).map(e=>({typeUrl:"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",value:{delegatorAddress:this.address,validatorAddress:e}})),s={amount:[{denom:this.denom,amount:this.fee}],gas:this.claimFeeGas};return this.sign(t,s)}async getInfo(){const{balance:e,balances:t}=await this.getProvider("balance2").getInfo(this.address,this.denom),s=this.toMinimalUnit(t.available),i=new this.BN(s).sub(new this.BN(this.fee)).sub(new this.BN(this.reserveForStake));return this.balance=e,this.balances=t,this.balances.availableForStake=Number(i)>0?this.toCurrencyUnit(i):0,{balance:this.balance,balances:this.balances}}setPrivateKey(e,t){this.privateKey=e;const s=Object(P.stringToPath)(this.derivation);S.DirectSecp256k1HdWallet.fromMnemonic(t,{hdPaths:[s],prefix:this.prefix}).then(e=>{this.wallet=e})}},K=s(626),L=s.n(K);var I=e=>class extends e{get instance(){return{id:this.id,ticker:this.ticker,name:this.name,decimal:this.decimal,alias:this.alias,parent:this.parent,BN:g.a,toCurrencyUnit:e=>this.toCurrencyUnit(e),toMinimalUnit:e=>this.toMinimalUnit(e),coreLibrary:this.coreLibrary,getAddressFromPublicKey:e=>this.getAddressFromPublicKey(e),getScriptPubKey:()=>this.coreLibrary.Script.fromAddress(this.address).toHex(),feeCoefficient:this.coefficient,feeDefault:this.feeData&&this.feeData.fee}}loadWallet(e){return new Promise((t,s)=>{const i=this.coreLibrary.HDPrivateKey.fromSeed(e,this.network),{privateKey:a}=i[this.getDeriveFunctionName()](this.derivation);a||s(new r.i({type:n.n,error:"can't derive privateKey!",instance:this})),this.privateKey=a.toWIF(),this.address=this.getAddress(),t(this)})}getDeriveFunctionName(){return"deriveChild"}getAddress(){return this.privateKey?this.coreLibrary.PrivateKey.fromWIF(this.privateKey.toString()).toAddress(this.network).toString():new Error(this.ticker+" privateKey is empty!!!")}getAddressFromScript(e){const t=this.coreLibrary.Script(e);return this.coreLibrary.Address(t,this.network).toString()}async validateAddress(e){return this.coreLibrary.Address.isValid(e||this.address,this.network)}async createTransaction({address:e,amount:t,memo:s,userFee:i}){const a=await this.getUnspentOutputs(this.address,this.getScriptPubKey()),r=Number(i||await this.getFee({amount:t})),n=(new this.coreLibrary.Transaction).from(a).to(e,Number(t)).fee(r);return"XVG"===this.ticker&&(n.timestamp=Number((new Date).getTime().toString().slice(0,-3))),Number(this.feePerByte)>0&&n.feePerKb(1e3*this.getFeePerByte()),n.change(this.address),"function"==typeof n.enableRBF?n.enableRBF():console.warn(`[${this.ticker}] bitcore-lib does not have enableRBF function`),n.sign(this.privateKey).serialize()}createTransactionSync({inputs:e,outputs:t,fee:s}){const i=t.filter(e=>e.address).map(({address:e,value:t})=>({address:e,satoshis:t})),a=(new this.coreLibrary.Transaction).from(e).to(i);return s&&a.fee(s).change(this.address),"function"==typeof a.enableRBF?a.enableRBF():console.warn(`[${this.ticker}] bitcore-lib does not have enableRBF function`),a.sign(this.privateKey).serialize()}createReplacementTx({tx:e,fee:t}){const s=this.address,i=[];for(const t of e.vin)i.push({txid:t.txid,vout:t.vout||0,script:this.getScriptPubKey(),satoshis:Number(t.value)});const a=[];let r=!1;for(const i of e.vout){if(1!==i.addresses.length)throw new Error("incompatible tx: tx output must have exacly one address");const e=i.addresses[0];let n;e!==s||r?n=Number(i.value):(n=Number(i.value)-t,r=!0),a.push({address:e,satoshis:n})}return(new this.coreLibrary.Transaction).from(i).to(a).sign(this.privateKey).serialize()}getScriptPubKey(){return this.coreLibrary.Script.fromAddress(this.address).toHex()}decodeTransaction(e){return new this.coreLibrary.Transaction(e)}async getCoins({address:e,value:t,feePerByte:s}){const i=(await this.getUnspentOutputs(this.address,this.getScriptPubKey())).map(e=>({...e,value:Number(e.value)})),a=L()(i,[{address:e,value:t}],s);if(!a.inputs||!a.outputs)throw new Error("Could not select utxos");return a}},D=s(1636),U=s(22),F=s(1637);var E=e=>class extends e{constructor(e){super(...arguments),this.setProviders(e.explorers)}setProviders(e,t){const s=this.filterProviders(e),i=Object(D.diff)(this.providersConfig,s);Object.keys(i).length>0&&s.length>0&&(this.providers=new F.a({config:{explorers:s,webUrl:t},wallet:this.instance}),this.providersConfig=s,console.warn(`[${this.ticker}] providers has been updated`)),Object.keys(i).length>0&&0===s.length&&console.warn(`[${this.ticker}] HasProviders update warning: server config is different, but no valid providers found. Server config should define 'usedFor' property to define valid providers. Update server config or remove HasProviders mixin from a coin.`)}filterProviders(e){return e.filter(e=>Array.isArray(e.usedFor))}handleError(e,t){e.message=`[${this.ticker}] Providers::${t} error: ${e.message||"Unknown error"}`,U.a.error({instance:this,error:e})}getProvider(e){var t,s;return(null===(t=this.providers)||void 0===t?void 0:t[e])||(null===(s=this.providers)||void 0===s?void 0:s.default)||this.explorer}async getBalance(){return this.getProvider("balance").getBalance(this.address,!0)}async getTransactions(...e){try{if(!this.address)throw new Error(`[${this.ticker}] getTransactions error: address is not loaded`);return this.getProvider("history").getTransactions({...e,address:this.address})}catch(e){return console.error(e),this.transactions||[]}}async getInfo(){const e=await this.getBalance();return this.balance=e,{balance:e}}getUnspentOutputs(e=this.address,t){return t||"function"!=typeof this.getScriptPubKey||(t=this.getScriptPubKey()),this.getProvider("utxo").getUnspentOutputs(e,t)}getUTXO(){return this.getProvider("utxo").getUnspentOutputs(this.address)}sendTransaction(e){return this.getProvider("send").sendTransaction(e)}getTransaction(e){return this.getProvider("tx").getTransaction(this.address,e)}updateCoinParamsFromServer(e){e.txWebUrl&&this.explorer&&(this.explorer.webUrl=e.txWebUrl),e.chainID&&(this.chainId=e.chainID),e.branchId&&(this.branchId=e.branchId);try{return this.setProviders(e.explorers,e.txWebUrl),e.feeData&&(this.feeData=e.feeData,this.fee=e.feeData.fee,e.feeData.stakingContract&&(this.stakingContract=e.feeData.stakingContract),e.feeData.stakingProxyContract&&(this.stakingProxyContract=e.feeData.stakingProxyContract),e.feeData.stakingFeeGas&&(this.stakingFeeGas=e.feeData.stakingFeeGas),e.feeData.unstakingFeeGas&&(this.unstakingFeeGas=e.feeData.unstakingFeeGas),e.feeData.claimFeeGas&&(this.claimFeeGas=e.feeData.claimFeeGas),e.feeData.tokenFeeGas&&(this.tokenFeeGas=e.feeData.tokenFeeGas),e.feeData.sendFeeGas&&(this.sendFeeGas=e.feeData.sendFeeGas),e.feeData.defaultGasPrice&&(this.sendFeeGas=e.feeData.defaultGasPrice),e.feeData.gasPriceCoefficient&&(this.sendFeeGas=e.feeData.gasPriceCoefficient),e.feeData.defaultMaxGasPrice&&(this.sendFeeGas=e.feeData.defaultMaxGasPrice),e.feeData.gasLimitCoefficient&&(this.sendFeeGas=e.feeData.gasLimitCoefficient),e.feeData.gasLimit&&(this.sendFeeGas=e.feeData.gasLimit),e.feeData.resendTimeout&&(this.sendFeeGas=e.feeData.resendTimeout),console.warn(`[${this.ticker}] fee and feeData has been updated`)),!0}catch(e){return e.message=`[${this.ticker}] updateCoinParamsFromServer error: ${e.message||"Unknown error"}`,U.a.error({instance:this,error:e}),!1}}};var O=e=>class extends e{get instance(){return{id:this.id,ticker:this.ticker,name:this.name,decimal:this.decimal,alias:this.alias,parent:this.parent,BN:g.a,toCurrencyUnit:e=>this.toCurrencyUnit(e),toMinimalUnit:e=>this.toMinimalUnit(e),coreLibrary:this.coreLibrary,getAddressFromPublicKey:e=>this.getAddressFromPublicKey(e),getScriptPubKey:()=>this.coreLibrary.address.toOutputScript(this.address,this.network).toString("hex"),feeCoefficient:this.coefficient,feeDefault:this.feeData&&this.feeData.fee}}async loadWallet(e){const t=this.coreLibrary.bip32.fromSeed(e,this.network).derivePath(this.derivation);if(!t)throw new r.i({type:n.x,error:new Error("can't get a privateKey!"),instance:this});return this.privateKey=t.toWIF(),this.address=this.getAddress(),this}getAddress(e=this.privateKey){const t=this.getKeyForSignFromPrivateKey(e);return e?this.getAddressFromPublicKey(t.publicKey):new r.i({type:n.x,error:new Error("privateKey is empty!"),instance:this})}getAddressFromPublicKey(e){return this.coreLibrary.payments.p2pkh({pubkey:e,network:this.network}).address}async validateAddress(e){if(!e)return!1;try{return this.coreLibrary.address.toOutputScript(e,this.network),!0}catch(e){return!1}}getTransactionBuilder(){return new this.coreLibrary.TransactionBuilder(this.network)}addInput(e,t){e.addInput(t.txId,t.outputIndex)}signInput(e,t,s,i){e.sign(s,t)}async createClaimTransaction(e){const t=this.getAddress(e);if(!t||0===t.length)throw new r.i({type:n.x,error:new Error("can't get a address from forked privateKey!"),instance:this});const s=await this.getUnspentOutputs(t);let i=this.explorer.calculateBalance(s);const a=await this.getFee(i,!0,t);if(i=new this.BN(i).sub(a).toString(),new this.BN(i).lt(new this.BN(0)))throw new r.f({type:n.s,error:new Error("Not enough otherside balance for claim"),instance:this});let o=new this.BN(0);const c=[],d=new this.BN(i).add(a);s.forEach(({txid:e,vout:t,address:s,script:i,value:a})=>{if(o.lt(d)){const r=new this.BN(a);o=o.add(r),c.push({txId:e,outputIndex:t,address:s,script:i,satoshis:parseInt(a,10)})}});const h=o.sub(new this.BN(i)).sub(a);if(h.lt(new this.BN(0)))throw new r.f({type:n.s,error:new Error("Insufficient funds!"),instance:this});return await this.buildTx(c,this.address,i,h,e,t,1)}async createTransaction({address:e,amount:t}){const s=await this.getUnspentOutputs(),i=await this.getFee({utxos:s});let a=new this.BN(0);const o=[],c=new this.BN(t).add(i);s.forEach(e=>{if(a.lt(c)){const t=new this.BN(e.value);a=a.add(t),o.push({txId:e.txid,outputIndex:e.vout,addres:e.address,script:e.script,satoshis:parseInt(e.value,10)})}});const d=a.sub(new this.BN(t)).sub(i);if(d.lt(new this.BN(0)))throw new r.f({type:n.s,error:new Error("Insufficient funds!"),instance:this});return await this.buildTx(o,e,t,d,void 0,void 0,1)}buildTx(e,t,s,i,a,o,c){return new Promise((d,h)=>{const l=this.getTransactionBuilder();c&&"BCD"!==this.ticker&&l.setVersion(c),e.forEach(e=>{this.addInput(l,e)}),l.addOutput(t,parseInt(s.toString(),10)),i.gt(new this.BN(0))&&l.addOutput(o||this.address,parseInt(i.toString(),10));const u=this.getKeyForSignFromPrivateKey(a);e.forEach((e,t)=>{try{this.signInput(l,u,t,e)}catch(e){throw new r.d({type:n.s,error:e,instance:this})}});try{d(l.build().toHex())}catch(e){h(e)}})}getKeyForSignFromPrivateKey(e=this.privateKey){return this.coreLibrary.ECPair.fromWIF(e,this.network)}getScriptPubKey(){return this.coreLibrary.address.toOutputScript(this.address,this.network).toString("hex")}},R=s(370),W=s.n(R),M=s(20),V=s(600);var $=e=>class extends e{async _selectTokens({parentTicker:e}){let t=[];return t=e?await M.e.tokens.where({parentTicker:e}).toArray().catch(e=>U.a.error({instance:this,error:e})):await M.e.tokens.toArray().catch(e=>U.a.error({instance:this,error:e})),t}async _insertBatchTokens(e){return await M.e.tokens.bulkPut(e),e}async _updateBatchTokens(e){const t=[];for(const s of e)t.push(this._updateToken(s));return await Promise.all(t),e}async _updateToken(e){const t=await M.e.tokens.where({uniqueField:e.uniqueField}).first().catch(e=>U.a.error({instance:this,error:e}));if(t&&t.id)return await M.e.tokens.update(t.id,e),e}async _removeToken(e){const t=await M.e.tokens.where({uniqueField:e}).first().catch(e=>U.a.error({instance:this,error:e}));t&&t.id&&await M.e.tokens.delete(t.id)}async loadTokensFromDb(e){return await this._selectTokens({parentTicker:e})}async insertTokensToDb(e){const t=e.map(e=>(e.parentTicker=this.parent,e)).filter(e=>e),[s]=await this.getUniquesAndDuplicates(e);return await this._insertBatchTokens(t.filter(e=>void 0===s[e.uniqueField])),t}async updateTokensInDb(e){const t=(await this.loadTokensFromDb(this.parent)).map(({uniqueField:e,name:t,ticker:s})=>({uniqueField:e,name:t,ticker:s})),s=e.map(({uniqueField:e,name:t,ticker:s})=>({uniqueField:e,name:t,ticker:s})).filter(e=>{for(let s=0;s<t.length;s+=1)if(t[s].uniqueField===e.uniqueField)return t[s].name!==e.name||t[s].ticker!==e.ticker;return!1}),i=e.map(e=>(e.parentTicker=this.parent,e)).filter(e=>{for(let t=0;t<s.length;t+=1)return s[t].uniqueField===e.uniqueField;return!1}).filter(Boolean);return await this._updateBatchTokens(i),i}async removeTokenFromDb(e){await this._removeToken(e)}async loadTokensList(e){try{this.bannedTokens=await this.getBannedTokenList()||[];const t="list",s=await this.getTokenList()||[],i=this.processTokenList(s,t),a=i.filter(e=>e.uniqueField).map(e=>e.uniqueField);await this.deleteDuplicates(i),await this.updateTokensInDb(i),await this.bulkDeleteNotInList(a);const r=(await M.e.tokens.where("uniqueField").anyOf(a).toArray()).map(e=>e.uniqueField),n=i.filter(e=>!r.includes(e.uniqueField));return await this.insertTokensToDb(n),this.createTokens(i,e)}catch(e){throw console.warn("[HasTokensMixin] loadTokensList failed with error "+e),new V.a({type:n.l,error:e,instnace:this})}}async fetchUserTokens(e){const t=await this.loadTokensFromDb(this.parent);t&&0===t.length?await this.loadTokensList(e):this.createTokens(t,e);const s=this.getUserTokenList?await this.getUserTokenList():[],i=await this.processTokenList(s,"user"),a=await this.insertTokensToDb(i);return this.createTokens(a,e)}processTokenList(e=[],t){return Array.isArray(e)?e.map(e=>this.getTokenObject(e,t)).filter(e=>this.isTokenExcluded(e)).filter(e=>!!e.ticker&&!!e.name&&/^[a-zA-Z0-9 -_.]+$/.test(e.ticker)).filter(e=>""!==e.ticker.trim()&&!(e.ticker.length>9||e.name.length>30)).map(e=>({...e,source:t})):[]}async getTokenList(){throw new r.h("getTokenList",this)}async getBannedTokenList(){return[]}getExcludedTokenList(){return(Array.isArray(this.bannedTokens)?this.bannedTokens:[]).map(e=>e.toLowerCase())}async getUserTokenList(){return[]}isTokenExcluded(e){return!this.getExcludedTokenList().includes(e.contract.toLowerCase())}getTokenObject(e,t){throw new r.h("Coin should define getTokenObject\n      to provide a logic processing of server token list")}async updateCustomToken(e,t){await this.removeTokenFromDb(e.uniqueField);for(const s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s]);const s={name:e.name,ticker:e.ticker,decimal:Number(e.decimal),contract:e.contract.toLowerCase(),parentTicker:e.parent,uniqueField:e.contract.toLowerCase(),isCustom:!0};return await this.insertTokensToDb([s])}createTokens(e=[],t){const s=e;0!==e.length?(s.forEach(e=>{const s=W.a.hash(e.ticker.toLowerCase()+e.contract.toLowerCase()),i=t.getWallet(s);if(i&&i.uniqueField===e.uniqueField)return void(i.visibility=e.visibility);const a=this.createToken(e.name,e.ticker,e.decimal,e.contract.toLowerCase(),e.uniqueField,!!e.isCustom,!1!==e.visibility);t.push(a),t.store.walletsCollection[a.alias].set(a.id.toUpperCase(),a),this.tokens[e.contract.toLowerCase()]=a}),this.bus&&this.bus.$emit("update::coin-list")):console.warn(this.ticker,"No tokens to create")}async getUniquesAndDuplicates(e){const t=await M.e.tokens.where("[parentTicker+uniqueField]").anyOf(e.filter(e=>!(null==e||!e.uniqueField||null==e||!e.parent)).map(e=>[this.parent,e.uniqueField])),s={},i=[];return await t.each(e=>{s[e.uniqueField]?i.push(e.id):s[e.uniqueField]=e.id}),[s,i]}async deleteDuplicates(e){try{const[,t]=await this.getUniquesAndDuplicates(e);return M.e.tokens.where("id").anyOf(t).delete()}catch(e){return void console.error(e)}}async bulkDeleteNotInList(e){const t=await M.e.tokens.where("parentTicker").equals(this.parent).filter(t=>!(t.isCustom||e.includes(t.uniqueField))).toArray();await M.e.tokens.where("id").anyOf(t.map(e=>e.id)).delete()}};s(28);var G=e=>class extends e{async getFee({utxos:e=null,feePerByte:t=null}={}){const s=e||await this.getUnspentOutputs(),i=this.calculateBalance(s),a=t||this.getFeePerByte(),r=i.toString(),n=s.map(({txid:e,vout:t,script:s,value:i,amount:a})=>({txId:e,vout:t,value:Number(i||a)})),{fee:o}=L()(n,[{address:this.mockAddress||this.address,value:Number(r)}],Number(a.toString()));return new this.BN(o)}getMultiplier(){return new this.BN(this.coefficient)}getFeePerByte(){return new this.BN(this.feePerByte).add(this.getMultiplier())}calculateBalance(e=[]){return e.reduce((e,{value:t})=>new this.BN(t).add(e),new this.BN("0"))}},H=s(106),q=s.n(H);var j=e=>class extends e{getAddress(){if(!this.privateKey)return new Error(this.ticker+" privateKey is empty!!!");let e=this.coreLibrary.PrivateKey.fromWIF(this.privateKey.toString()).toAddress(this.network).toString();return q.a.isCashAddress(e)||(e=this.convertToCashAddress(e)),e}convertToLegacyAddress(e){return q.a.toLegacyAddress(e)}convertToCashAddress(e){return q.a.toCashAddress(e)}async validateAddress(e){try{return q.a.isLegacyAddress(e)||q.a.isCashAddress(e)}catch(e){return!1}}async createTransaction({address:e,amount:t}){const s=await this.getUnspentOutputs(),i=Number(await this.getFee(t)),a=q.a.isCashAddress(e)?e:q.a.toCashAddress(e),r=q.a.isCashAddress(this.address)?this.address:q.a.toCashAddress(this.address);return(new this.coreLibrary.Transaction).from(s).to(a,Number(t)).fee(i).feePerKb(1e3*this.getFeePerByte()).change(r).sign(this.privateKey).serialize()}}},877:function(e,t,s){"use strict";s.r(t);var i=s(888),a=s.n(i),r=s(155),n=s(4),o=s(3),c=s(469);const d=a.a.nettype_utils.network_type.MAINNET;class XMRCoin extends(Object(c.g)(r.a)){constructor({alias:e,feeData:t,explorers:s,txWebUrl:i,socket:a}){super({alias:e,name:"Monero",ticker:"XMR",decimal:12,derivation:"m/44'/128'/0'/0/0",unspendableBalance:"0",explorers:s,txWebUrl:i,socket:a}),this.fee=t.fee,this.coreLibrary=null,this.privateKey=null,this.privateKeyView=null,this.privateKeySpend=null,this.publicKeySpend=null,this.info={},this.mixin=11,this.dustThreshold=1e6}get instance(){return{ticker:this.ticker,name:this.name,alias:this.alias,assetName:this.assetName,decimal:this.decimal,parent:this.parent,toCurrencyUnit:e=>this.toCurrencyUnit(e),toMinimalUnit:e=>this.toMinimalUnit(e),filterTransactions:this.filterTransactions.bind(this),feeDefault:this.feeData&&this.feeData.fee}}filterTransactions(e){return void 0===e.spent_outputs||!this.checkKeyImage({txPubKey:e.spent_outputs[0].tx_pub_key,outIndex:e.spent_outputs[0].out_index,spentOutputs:[e.spent_outputs[0].key_image]})}async loadWallet(e){const t=e.toString("hex").substr(0,64);return await this.setPrivateKey(t),this}getAddress(e=this.privateKey){const t=this.coreLibrary.address_and_keys_from_seed(e,d);return this.privateKeyView=t.sec_viewKey_string,this.privateKeySpend=t.sec_spendKey_string,this.publicKeySpend=t.pub_spendKey_string,t.address_string}validateAddress(e){try{return this.coreLibrary.decode_address(e,d),!0}catch(e){return!1}}async createTransaction({address:e,amount:t,memo:s,isSendAll:i=!1,utxos:a}){return{address:e,amount:t,memo:s,isSendAll:i,utxos:a}}async sendTransaction({address:e,amount:t,memo:s,isSendAll:i=!1,utxos:a}){return new Promise((r,c)=>this.coreLibrary.async__send_funds({is_sweeping:i,payment_id_string:s,sending_amount:String(t),from_address_string:this.address,sec_viewKey_string:this.privateKeyView,sec_spendKey_string:this.privateKeySpend,pub_spendKey_string:this.publicKeySpend,to_address_string:e,priority:1,unlock_time:0,nettype:d,get_unspent_outs_fn:(e,t)=>{a?t(null,a):this.getUnspentOutputs({address:e.address,secViewKey:e.view_key,mixin:e.mixin,dustThreshold:e.dust_threshold}).then(e=>{e.outputs=e.outputs.map(e=>{const t=e;return t.rct&&"0000000000000000000000000000000000000000000000000000000000000000"===t.rct.slice(64,128)&&"000000000000000000000000000000000000000000000000"===t.rct.slice(144,192)&&(t.rct=t.rct.slice(0,64)+t.rct.slice(128,144)),t}),t(null,e)}).catch(e=>t(e))},get_random_outs_fn:(e,t)=>{this.getProvider("utxo").random(e).then(e=>{Array.isArray(e.amount_outs)&&e.amount_outs.forEach(e=>{Array.isArray(e.outputs)&&e.outputs.forEach(e=>{e.rct&&"0000000000000000000000000000000000000000000000000000000000000000"===e.rct.slice(64,128)&&"000000000000000000000000000000000000000000000000"===e.rct.slice(144,192)&&(e.rct=e.rct.slice(0,64)+e.rct.slice(128,144))})}),t(null,e)}).catch(e=>t(e))},submit_raw_tx_fn:(e,t)=>{this.getProvider("send").submit({tx:e.tx,address:e.address,viewKey:e.view_key}).then(s=>t(null,{result:s,tx:e.tx})).catch(e=>t(e))},status_update_fn:e=>{},error_fn:e=>{c(new n.i({type:o.x,error:new Error(e.err_msg),instance:this}))},success_fn:e=>{r({rawTx:e.serialized_signed_tx,txid:e.tx_hash})}}))}async getFee({amount:e=null,isSendAll:t=!1,utxos:s}={}){const i=new this.BN(String(e)),a=s||await this.getUnspentOutputs({address:this.address,secViewKey:this.privateKeyView,mixin:this.mixin,dustThreshold:this.dustThreshold,publicKeySpend:this.publicKeySpend,privateKeySpend:this.privateKeySpend});if(!a.outputs)return new this.BN(0);a.outputs=a.outputs.map(e=>{const t=e;return t.rct&&"0000000000000000000000000000000000000000000000000000000000000000"===t.rct.slice(64,128)&&"000000000000000000000000000000000000000000000000"===t.rct.slice(144,192)&&(t.rct=t.rct.slice(0,64)+t.rct.slice(128,144)),t});let r=new this.BN("0");const n=t?a.outputs.length:a.outputs.reduce((e,{amount:t})=>(r.lt(i)&&(e+=1),r=new this.BN(t).add(r),e),0),o=await this.coreLibrary.estimate_fee({use_per_byte_fee:!0,use_rct:!0,n_inputs:n,mixin:this.mixin,n_outputs:t?1:2,extra_size:0,bulletproof:!0,base_fee:this.fee,fee_quantization_mask:1e4,priority:1,fork_version:12,clsag:!0});return new this.BN(o)}async getInfo(){const e=await this.getProvider("balance").getInfo({address:this.address,viewKey:this.privateKeyView});if(!e)return{};this.info=e;const t=e.spent_outputs.filter(e=>this.checkSpentOutputKeyImage({txPubKey:e.tx_pub_key,outIndex:e.out_index,imageToCheck:e.key_image,privateKeyView:this.privateKeyView,publicKeySpend:this.publicKeySpend,privateKeySpend:this.privateKeySpend})).reduce((e,t)=>e.add(new this.BN(t.amount)),new this.BN(0));return e.spent_outputs=null,this.balance=new this.BN(e.total_received).sub(t).toString(),{balance:this.balance}}async availableBalance(){const e=await this.getUnspentOutputs({address:this.address,secViewKey:this.privateKeyView,mixin:this.mixin,dustThreshold:this.dustThreshold,publicKeySpend:this.publicKeySpend,privateKeySpend:this.privateKeySpend}),t=e.outputs.reduce((e,{amount:t})=>new this.BN(t).add(e),new this.BN("0"));if(t.lten(0))return"0";const s=await this.getFee({amount:null,isSendAll:!0,utxos:e}),i=t.sub(s);return i.lten(0)?"0":this.toCurrencyUnit(i)}async setPrivateKey(e){this.coreLibrary=await a.a.monero_utils_promise;const t=this.coreLibrary.address_and_keys_from_seed(e,d);return this.privateKeyView=t.sec_viewKey_string,this.privateKeySpend=t.sec_spendKey_string,this.publicKeySpend=t.pub_spendKey_string,this.address=t.address_string,this.privateKey=e,this.getProvider("account").postAccount(t.address_string),t}async getTransactions(){return this.getProvider("history").getTransactions({address:this.address,viewKey:this.privateKeyView,lastHeight:this.info.scanned_block_height})}async getUnspentOutputs({address:e=this.address,secViewKey:t=this.privateKeyView,mixin:s=this.mixin,dustThreshold:i=this.dustThreshold,useDust:a=this.useDust}={}){const r=await this.getProvider("utxo").unspent({address:e,secViewKey:t,mixin:s,dustThreshold:i,useDust:a});return r.outputs=r.outputs.filter(e=>this.checkKeyImage({txPubKey:e.tx_pub_key,outIndex:e.index,spentOutputs:e.spend_key_images,privateKeyView:this.privateKeyView,publicKeySpend:this.publicKeySpend,privateKeySpend:this.privateKeySpend})),r}checkKeyImage({txPubKey:e,outIndex:t,spentOutputs:s}){const i=this.coreLibrary.generate_key_image(e,this.privateKeyView,this.publicKeySpend,this.privateKeySpend,t);let a=!0;for(let e=0;e<s.length;e++)if(s[e]===i){a=!1;break}return a}checkSpentOutputKeyImage({txPubKey:e,outIndex:t,imageToCheck:s}){return this.coreLibrary.generate_key_image(e,this.privateKeyView,this.publicKeySpend,this.privateKeySpend,t)===s}async resync(){const e=await this.getProvider("resync").resync(this.address,this.privateKeyView);return e&&(this.info.scanned_block_height=null),e}}t.default=XMRCoin},879:function(e,t,s){"use strict";s.r(t);var i=s(28),a=s.n(i),r=s(74),n=s.n(r),o=s(1638),c=s.n(o),d=s(155),h=s(4),l=s(3),u=s(469),p=s(896);class XTZCoin extends(Object(u.g)(d.a)){constructor({alias:e,feeData:t,explorers:s,txWebUrl:i,socket:a}){super({alias:e,name:"Tezos",ticker:"XTZ",decimal:6,derivation:"m/44'/1729'/0'/0/0",unspendableBalance:"275000",explorers:s,txWebUrl:i,socket:a,feeData:t}),this.network="",this.plugins=[new p.a],this.coreLibrary=c.a,this.prefix={tz1:new Uint8Array([6,161,159]),edpk:new Uint8Array([13,15,37,217]),edsk:new Uint8Array([43,246,78,7]),edsig:new Uint8Array([9,245,205,134,18])},this.eventEmmiter.on(this.ticker+"::confirmed-socket-tx",(e,t,s)=>{this.getInfo(),t&&t.direction?this.bus.$emit("socket::newtx",{id:this.id,ticker:s,amount:t.amount,txid:t.txid}):this.bus.$emit("socket::newtx::outgoing",{id:this.id,ticker:s})})}loadWallet(e){return new Promise((t,s)=>{const i=this.coreLibrary.crypto_sign_seed_keypair(e.slice(0,32));i||s(new Error(this.ticker+" can't get a privateKey!!!")),this.privateKey=this.bs58EncodeWithPrefix(i.privateKey,this.prefix.edsk),this.address=this.bs58EncodeWithPrefix(this.coreLibrary.crypto_generichash(20,i.publicKey),this.prefix.tz1),t(this)})}getAddress(){return this.privateKey?this.bs58EncodeWithPrefix(this.coreLibrary.crypto_generichash(20,this.bs58Decode(this.privateKey,this.prefix.edsk).slice(32)),this.prefix.tz1):new h.i({type:l.n,error:new Error("privateKey is empty!"),instance:this})}async validateAddress(e){if(!e)return!1;try{return this.bs58Decode(e,this.prefix.tz1),!0}catch(e){return!1}}async create(e){if(!this.privateKey)throw new Error("[XTZ] forge() error: no privateKey");const t=await this.getFee(),s=this.bs58EncodeWithPrefix(this.bs58Decode(this.privateKey,this.prefix.edsk).slice(32),this.prefix.edpk),i={headers:{"Content-Type":"application/json"}},r=this.getProvider("send").config.baseUrl,[n,o,c]=await Promise.all([a.a.get(r+"/chains/main/blocks/head/header").then(e=>e.data),a.a.get(`${r}/chains/main/blocks/head/context/contracts/${this.address}/counter`).then(e=>e.data),a.a.get(`${r}/chains/main/blocks/head/context/contracts/${this.address}/manager_key`).then(e=>e.data)]),d=[];let u=Number(o);c||(u+=1,d.push({kind:"reveal",fee:t.toString(),gas_limit:this.config.config.feeData.gasLimit,storage_limit:this.config.config.feeData.storageLimit,public_key:s,source:this.address,counter:String(u)})),u+=1,e.counter=String(u),d.push(Object.assign(e,{fee:t.toString(),source:this.address,counter:String(u),gas_limit:this.config.config.feeData.gasLimit,storage_limit:this.config.config.feeData.storageLimit}));const p={branch:n.hash,contents:d},m=n.protocol,g=(await a.a.post(`${r}/chains/${n.chain_id}/blocks/${n.hash}/helpers/forge/operations`,p,i)).data;p.protocol=m;const f=this.sign(g),y=f.sbytes;p.signature=f.edsig;const w=await a.a.post(r+"/chains/main/blocks/head/helpers/preapply/operations",[p],i);if(!Array.isArray(w.data))throw new h.d({type:l.s,error:new TypeError(this.ticker+" node fail check transaction!"),instance:this});const b=w.data.reduce((t,s,i)=>(t.push(...s.contents.reduce((t,{destination:s,metadata:i})=>("transaction"===e.kind&&s&&s!==e.destination&&t.push("operation is malicious, destination changed"),void 0!==i.operation_result&&"failed"===i.operation_result.status&&t.push(...i.operation_result.errors),t),[])),t),[]);if(b.length>0)throw new h.d({type:l.s,error:b.join(),instance:this});return y}async createTransaction({address:e,amount:t}){return this.create({kind:"transaction",amount:t.toString(),destination:e})}async createDelegationTransaction(e){return this.create({kind:"delegation",delegate:e})}async sendTransaction(e){const t={headers:{"Content-Type":"application/json"}},s=this.getProvider("send").config.baseUrl;try{return{txid:(await a.a.post(s+"/injection/operation",JSON.stringify(e),t)).data}}catch(e){throw new h.d({type:l.s,error:e,instance:this})}}sign(e){const t=new Uint8Array([3]);let s=this.hex2buf(e);s=this.mergebuf(t,s);const i=this.coreLibrary.crypto_sign_detached(this.coreLibrary.crypto_generichash(32,s),this.bs58Decode(this.privateKey,this.prefix.edsk),"uint8array");return{bytes:e,sig:i,edsig:this.bs58EncodeWithPrefix(i,this.prefix.edsig),sbytes:e+this.buf2hex(i)}}bs58EncodeWithPrefix(e,t){const s=new Uint8Array(t.length+e.length);return s.set(t),s.set(e,t.length),n.a.encode(Buffer.from(s,"hex"))}bs58Decode(e,t){return n.a.decode(e).slice(t.length)}buf2hex(e){const t=new Uint8Array(e),s=[];for(let e=0;e<t.length;e+=1){const i=16,a=-2,r=("00"+t[e].toString(i)).slice(a);s.push(r)}return s.join("")}hex2buf(e){return new Uint8Array(e.match(/[\da-f]{2}/gi).map(e=>parseInt(e,16)))}mergebuf(e,t){const s=new Uint8Array(e.length+t.length);return s.set(e),s.set(t,e.length),s}async getInfo(){return await this.getBalance(),{balance:this.balance,balances:this.balances,transactions:[]}}async getBalance(){this.balance=this.toMinimalUnit(await this.getProvider("balance").getBalance(this.address));const e=await this.getProvider("balance").getDelegate(this.address).catch(e=>console.error(e));this.balances={available:this.toCurrencyUnit(this.balance),staking:{total:e?this.toCurrencyUnit(this.balance):"0",validator:e||""}}}getTransactions(){return this.getProvider("history").getTransactions({address:this.address})}getTransaction(e){return this.getProvider("history").getTransaction(this.address,e)}}t.default=XTZCoin},887:function(e,t,s){"use strict";const i={BTCCoin:()=>s.e(296).then(s.bind(null,4221)),ETHCoin:()=>s.e(220).then(s.bind(null,4222)),BNBCoin:()=>Promise.all([s.e(269),s.e(251),s.e(198),s.e(186),s.e(196),s.e(201)]).then(s.bind(null,4223)),DOGECoin:()=>s.e(298).then(s.bind(null,4224)),SOLCoin:()=>s.e(273).then(s.bind(null,4225)),ADACoin:()=>s.e(291).then(s.bind(null,4226)),ZILCoin:()=>s.e(283).then(s.bind(null,4227)),MATICCoin:()=>s.e(226).then(s.bind(null,4272)),DOTCoin:()=>Promise.all([s.e(4),s.e(0),s.e(299)]).then(s.bind(null,4228)),BSCCoin:()=>s.e(218).then(s.bind(null,4229)),TRXCoin:()=>s.e(282).then(s.bind(null,4230)),XRPCoin:()=>Promise.all([s.e(267),s.e(262),s.e(211),s.e(256),s.e(175),s.e(181)]).then(s.bind(null,4231)),ATOMCoin:()=>s.e(292).then(s.bind(null,4232)),BANDCoin:()=>s.e(293).then(s.bind(null,4233)),ICXCoin:()=>s.e(305).then(s.bind(null,4273)),LTCCoin:()=>s.e(307).then(s.bind(null,4234)),NEOCoin:()=>Promise.all([s.e(6),s.e(310)]).then(s.bind(null,4235)),ONGCoin:()=>s.e(311).then(s.bind(null,4236)),ONTCoin:()=>s.e(312).then(s.bind(null,4237)),RVNCoin:()=>s.e(313).then(s.bind(null,4238)),XLMCoin:()=>Promise.all([s.e(216),s.e(231),s.e(260)]).then(s.bind(null,4239)),XTZCoin:()=>Promise.resolve().then(s.bind(null,879)),XVGCoin:()=>Promise.all([s.e(224),s.e(225),s.e(270),s.e(237),s.e(316)]).then(s.bind(null,4240)),ETCCoin:()=>s.e(229).then(s.bind(null,4241)),ZECCoin:()=>s.e(193).then(s.bind(null,4242)),VETCoin:()=>Promise.all([s.e(253),s.e(264),s.e(250)]).then(s.bind(null,4243)),XEMCoin:()=>s.e(314).then(s.bind(null,4244)),KMDCoin:()=>Promise.all([s.e(1),s.e(306)]).then(s.bind(null,4274)),ALGOCoin:()=>s.e(279).then(s.bind(null,4245)),DASHCoin:()=>Promise.all([s.e(245),s.e(214),s.e(263),s.e(257),s.e(212),s.e(233)]).then(s.bind(null,4246)),HBARCoin:()=>s.e(304).then(s.bind(null,4247)),QTUMCoin:()=>Promise.all([s.e(219),s.e(221),s.e(249),s.e(320)]).then(s.bind(null,4248)),TPAYCoin:()=>s.e(200).then(s.bind(null,4249)),NANOCoin:()=>s.e(252).then(s.bind(null,4275)),SMARTCoin:()=>s.e(205).then(s.bind(null,4250)),WAVESCoin:()=>Promise.all([s.e(207),s.e(173),s.e(248),s.e(208),s.e(238),s.e(177),s.e(239),s.e(210),s.e(278),s.e(222),s.e(240),s.e(255),s.e(178),s.e(179)]).then(s.bind(null,4251)),AECoin:()=>s.e(265).then(s.bind(null,4271)),ARKCoin:()=>Promise.all([s.e(174),s.e(213),s.e(246),s.e(285),s.e(199),s.e(182),s.e(247),s.e(187),s.e(241),s.e(204),s.e(230),s.e(217),s.e(236),s.e(268),s.e(259)]).then(s.bind(null,4252)),BCDCoin:()=>s.e(209).then(s.bind(null,4253)),BCHCoin:()=>Promise.all([s.e(2),s.e(5),s.e(3),s.e(294)]).then(s.bind(null,4254)),BSVCoin:()=>Promise.all([s.e(2),s.e(5),s.e(3),s.e(295)]).then(s.bind(null,4255)),BTGCoin:()=>s.e(191).then(s.bind(null,4256)),DCRCoin:()=>Promise.all([s.e(223),s.e(197),s.e(242),s.e(319)]).then(s.bind(null,4257)),DGBCoin:()=>s.e(297).then(s.bind(null,4258)),XMRCoin:()=>Promise.resolve().then(s.bind(null,877)),FIOCoin:()=>s.e(301).then(s.bind(null,4259)),LSKCoin:()=>Promise.all([s.e(261),s.e(192),s.e(190)]).then(s.bind(null,4260)),EOSCoin:()=>s.e(300).then(s.bind(null,4261)),YECCoin:()=>Promise.all([s.e(1),s.e(315)]).then(s.bind(null,4276)),GASCoin:()=>Promise.all([s.e(6),s.e(303)]).then(s.bind(null,4262)),GRSCoin:()=>s.e(189).then(s.bind(null,4263)),NEO3Coin:()=>Promise.all([s.e(7),s.e(309)]).then(s.bind(null,4264)),GAS3Coin:()=>Promise.all([s.e(7),s.e(302)]).then(s.bind(null,4265)),NEARCoin:()=>s.e(272).then(s.bind(null,4266)),AVAXCoin:()=>s.e(228).then(s.bind(null,4267)),LUNCCoin:()=>s.e(280).then(s.bind(null,4268)),LUNACoin:()=>s.e(308).then(s.bind(null,4269)),THETACoin:()=>s.e(281).then(s.bind(null,4270))};t.a=i},896:function(e,t,s){"use strict";s.d(t,"a",(function(){return n}));var i=s(28),a=s.n(i),r=s(22);class DomainsPlugin_DomainsPlugin{static getUrlPathFromDomain(e){return"/domains/"+e.toLowerCase()}install(e){const t=e.validateAddress,s=a.a.create({baseURL:"https://unstoppabledomains.g.alchemy.com",headers:{Authorization:"Bearer 6eHDNnqMEACbD2138qv71oXjIaN5ZyHr"}});e.validateAddress=async function(i,a){const n=await t.call(e,i||e.address);if(n)return n;return await async function(e,t){var i;if(!e||0===e.length)return null;const a=await s.get(DomainsPlugin_DomainsPlugin.getUrlPathFromDomain(e)).catch(e=>r.a.error({instance:this,error:e}));return function(e,t){var s;return null!==(s=null==e?void 0:e[`crypto.${t}.address`])&&void 0!==s?s:null}(null==a||null===(i=a.data)||void 0===i?void 0:i.records,t)}(i,this.ticker)}}}var n=DomainsPlugin_DomainsPlugin}}]);