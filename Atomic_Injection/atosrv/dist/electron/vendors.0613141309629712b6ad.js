(window.webpackJsonp=window.webpackJsonp||[]).push([[291],{4226:function(t,e,s){"use strict";s.r(e);var a=s(155),r=s(4),i=s(3),n=s(383),o=s(896),d=s(469);const c=window.fetch,h=(t,e)=>{try{WebAssembly.instantiateStreaming=void 0}catch(t){console.error("WebAssembly not supported")}return new Promise((function(s,a){const r=new XMLHttpRequest;t.endsWith(".wasm")&&(r.responseType="arraybuffer"),r.open(e&&e.method||"GET",t),r.addEventListener("load",(function(){this.status>=200&&this.status<300?s({json:()=>JSON.parse(r.response),ok:!0,arrayBuffer:()=>r.response}):a({status:this.status,statusText:r.statusText})})),r.addEventListener("error",(function(){a({status:this.status,statusText:r.statusText})})),r.send()}))};class ADACoin extends(Object(d.g)(a.a)){constructor({alias:t,feeData:e,explorers:a,txWebUrl:r,submitUrl:i,socket:d}){const l={alias:t,name:"Cardano",ticker:"ADA",decimal:6,derivation:"m/44'/1815'/0'/0/0",unspendableBalance:"0",explorers:a,txWebUrl:r,socket:d,feeData:e,submitUrl:i||"https://adalite.io/api/txs/submit",dustAmount:"1000000"},y={feeCoefficient:e.feePerByte||"44",feeConst:e.constantPart||"2800000"};super(l),"object"==typeof WebAssembly?(console.warn("Loading Cardano-wasm modules"),window.fetch=h,Promise.all([s.e(284).then(s.bind(null,4678)),Promise.all([s.e(275),s.e(286)]).then(s.bind(null,7717))]).then(t=>{window.fetch=c,this.coreLibrary=new n.a(...t,y)})):(console.warn("Cardano-wasm modules not supported,  ASM.js loaded instead"),Promise.all([s.e(318).then(s.bind(null,7949)),Promise.all([s.e(274),s.e(317)]).then(s.bind(null,7719))]).then(t=>{this.coreLibrary=new n.a(...t,y)})),this.privateKey={},this.legacyCore=n.b,this.plugins=[new o.a],this.feePerByte=e.feePerByte,this.constantPart=e.constantPart}setPrivateKey(t,e){let s=t;t&&t.shelleyKey&&(s=t.shelleyKey);if(!this.coreLibrary.validateShelleyPrivateKey(s))throw this.privateKey.byronKey=s,new Error("Legacy Byron Private key appears");this.privateKey.shelleyKey=s,this.privateKey.byronKey=t.byronKey,this.privateKey.byronAddress=t.byronAddress,this.coreLibrary.getCip1852AccountFromPrivateKey(s),this.coreLibrary.getLegacyAccountFromMnemonic(e)}async setAddress(t){this.coreLibrary.validateShelleyAddress(t)?this.address=t:this.privateKey.byronAddress=t}getAddress(){return this.privateKey.shelleyKey?this.address:new r.i({type:i.n,error:new Error("Could not get address, pkey is not exists"),instance:this})}async loadWallet(t,e){try{this.privateKey.shelleyKey=await this.coreLibrary.getPrivateKeyByMnemonic(e),this.privateKey.byronKey=await this.coreLibrary.getLegacyPrivateKeyByMnemonic(e),this.coreLibrary.getLegacyAccountFromMnemonic(e),this.privateKey.byronAddress=await this.coreLibrary.getLegacyAddressByPrivateKeySync(this.privateKey.byronKey),this.address=await this.coreLibrary.getAddressByPrivateKey()}catch(t){console.error(t),console.error("ADA load walled failed, core library is not initialized")}return this}async validateAddress(t){return this.coreLibrary.validateAddress(t)}async isDustAmount(t,e){const s=e||await this.availableBalance(),a=new this.BN(this.dustAmount),r=new this.BN(this.toMinimalUnit(s)),i=new this.BN(this.toMinimalUnit(t)),n=r.sub(i);return i.lt(a)?"Minimal amount to send is 1 ADA":!(!n.gt(new this.BN("0"))||!n.lt(a))&&"Minimal change is 1 ADA, try to send another amount"}async createTransaction({address:t,amount:e,changeAddress:s=this.address}){if("string"!=typeof t)throw new TypeError("ADA: createTransaction: address must be string");if("string"!=typeof e)throw new TypeError("ADA: createTransaction: amount must be string");if(!this.privateKey.shelleyKey)throw new r.i({type:i.s,error:new Error("privateKey must be loaded"),instance:this});this.lastblock=await this.getProvider("block").getLatestBlock();const a=await this.getUnspentOutputs(s);try{return this.coreLibrary.createTransaction({address:t,amount:e,changeAddress:s,utxo:a,slotNo:this.lastblock.slot_no})}catch(t){throw new r.i({type:i.s,error:t,instance:this})}}async createClaimTransaction(t){const e=t||await this.getLegacyAddressUnspentOutputs();if(!e||0===e.length)throw new Error("Nothing to claim");const s=await this.getProvider("block").getLatestBlock(),a=await this.getLegacyAddressAvailableBalance({address:this.address,legacyUtxo:e});return this.coreLibrary.createTransaction({address:this.address,amount:a,changeAddress:this.privateKey.byronAddress,utxo:e,slotNo:s.slot_no})}async getLegacyAddressUnspentOutputs(){const{byronAddress:t}=this.privateKey;return await this.getUnspentOutputs(t)}async getLegacyAddressAvailableBalance({legacyUtxo:t,address:e}){const{byronAddress:s}=this.privateKey,a=t||await this.getUnspentOutputs(s),r=a.reduce((t,e)=>t.add(new this.BN(e.amount)),new this.BN("0"));if(0===Number(r))return r;const i=await this.getFee({amount:r,address:e,utxos:a,changeAddress:s}),n=r.sub(i);return n.lt(new this.BN(this.dustAmount))?new this.BN("0"):n.toString()}getUnspentOutputs(t=this.address){return this.getProvider("utxo").getUnspentOutputs(t)}async getFee({amount:t=null,address:e,utxos:s,changeAddress:a}={}){const r=e&&e.length>0?e:this.address,i=s||await this.getUnspentOutputs(a||this.address);this.lastblock=await this.getProvider("block").getLatestBlock();let n=Number(t);n||(n=Number(this.balance)?this.balance:"1");const o=this.coreLibrary.estimateFee({address:r,amount:n,outputs:i,ttl:this.lastblock.slot_no});return new this.BN(o)}async getInfo(){const t=await this.getBalance(),e=this.coreLibrary.getRewardAddress(this.address).to_address().to_bech32(),s=await this.getProvider("balance").getAccountState(e);return this.balance=t,this.balances={available:this.toCurrencyUnit(t),rewards:s&&s.reward,staking:{total:s&&s.poolId?this.balance:"0",validator:s&&s.poolId}},{balance:this.balance,balances:this.balances}}async createDelegationTransaction(t,e){if(!this.privateKey.shelleyKey)throw new r.i({type:i.s,error:new Error("privateKey must be loaded"),instance:this});this.lastblock=await this.getProvider("block").getLatestBlock();const s=await this.getUnspentOutputs(this.address);return this.coreLibrary.createDelegationTransaction({utxo:s,slotNo:this.lastblock.slot_no,paymentAddress:this.address,poolId:t,stakeAddressRegistered:e})}async stake(t){const e=this.coreLibrary.getRewardAddressHexFromAddressStr(this.address),{[e]:s}=await this.getProvider("regHistory").getRegistrationHistory(e),a=s&&s[0]&&"StakeRegistration"===s[0].certType,r=await this.createDelegationTransaction(t,a);return this.sendTransactionOnce(r)}async claim(){this.lastblock=await this.getProvider("block").getLatestBlock();const t=await this.getUnspentOutputs(this.address),e=this.coreLibrary.getRewardAddress(this.address),s=e.to_address().to_bech32(),a=await this.getProvider("balance").getAccountState(s),r=await this.coreLibrary.createWithdrawalTransaction({paymentAddress:this.address,utxo:t,slotNo:this.lastblock.slot_no,rewardAddress:e,amountToWithdraw:a.reward});return this.sendTransactionOnce(r)}getDelegatedPoolKey(){const t=this.getProvider("history").lastDelegationCert;return t?t.poolKeyHash:""}get instance(){return{id:this.id,ticker:this.ticker,name:this.name,alias:this.alias,assetName:this.assetName,decimal:this.decimal,parent:this.parent,tokens:()=>this.tokens,toCurrencyUnit:t=>this.toCurrencyUnit(t),toMinimalUnit:t=>this.toMinimalUnit(t),updateBalances:(...t)=>this.updateBalances(...t),feeCoefficient:this.coefficient,feeDefault:this.feeData&&this.feeData.fee,getFee:t=>this.getFee(t)}}}e.default=ADACoin}}]);