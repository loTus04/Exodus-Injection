/*! For license information please see vendors.6d9c5f61d5e5f8b1e03b.js.LICENSE.txt */
(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{1334:function(t,e,n){"use strict";function r(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("Wrong positive integer: "+t)}function i(t){if("boolean"!=typeof t)throw new Error("Expected boolean, not "+t)}function o(t,...e){if(!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function s(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(t.outputLen),r(t.blockLen)}function a(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function c(t,e){o(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}Object.defineProperty(e,"__esModule",{value:!0}),e.output=e.exists=e.hash=e.bytes=e.bool=e.number=void 0,e.number=r,e.bool=i,e.bytes=o,e.hash=s,e.exists=a,e.output=c;const f={number:r,bool:i,bytes:o,hash:s,exists:a,output:c};e.default=f},220:function(t,e,n){"use strict";n.r(e),n.d(e,"CURVE",(function(){return f})),n.d(e,"ExtendedPoint",(function(){return ExtendedPoint})),n.d(e,"RistrettoPoint",(function(){return RistrettoPoint})),n.d(e,"Point",(function(){return Point})),n.d(e,"Signature",(function(){return Signature})),n.d(e,"getPublicKey",(function(){return Z})),n.d(e,"sign",(function(){return j})),n.d(e,"verify",(function(){return $})),n.d(e,"sync",(function(){return q})),n.d(e,"getSharedSecret",(function(){return X})),n.d(e,"curve25519",(function(){return Y})),n.d(e,"utils",(function(){return et}));var r=n(27);const i=BigInt(0),o=BigInt(1),s=BigInt(2),a=BigInt(255),c=s**BigInt(252)+BigInt("27742317777372353535851937790883648493"),f=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:s**a-BigInt(19),l:c,n:c,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),h=s**BigInt(256),u=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"),d=(BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742"),BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235")),l=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),y=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),w=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");class ExtendedPoint{constructor(t,e,n,r){this.x=t,this.y=e,this.z=n,this.t=r}static fromAffine(t){if(!(t instanceof Point))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return t.equals(Point.ZERO)?ExtendedPoint.ZERO:new ExtendedPoint(t.x,t.y,o,U(t.x*t.y))}static toAffineBatch(t){const e=function(t,e=f.P){const n=new Array(t.length),r=R(t.reduce((t,r,o)=>r===i?t:(n[o]=t,U(t*r,e)),o),e);return t.reduceRight((t,r,o)=>r===i?t:(n[o]=U(t*n[o],e),U(t*r,e)),r),n}(t.map(t=>t.z));return t.map((t,n)=>t.toAffine(e[n]))}static normalizeZ(t){return this.toAffineBatch(t).map(this.fromAffine)}equals(t){g(t);const{x:e,y:n,z:r}=this,{x:i,y:o,z:s}=t,a=U(e*s),c=U(i*r),f=U(n*s),h=U(o*r);return a===c&&f===h}negate(){return new ExtendedPoint(U(-this.x),this.y,this.z,U(-this.t))}double(){const{x:t,y:e,z:n}=this,{a:r}=f,i=U(t**s),o=U(e**s),a=U(s*U(n**s)),c=U(r*i),h=U(U((t+e)**s)-i-o),u=c+o,d=u-a,l=c-o,y=U(h*d),w=U(u*l),g=U(h*l),p=U(d*u);return new ExtendedPoint(y,w,p,g)}add(t){g(t);const{x:e,y:n,z:r,t:o}=this,{x:a,y:c,z:f,t:h}=t,u=U((n-e)*(c+a)),d=U((n+e)*(c-a)),l=U(d-u);if(l===i)return this.double();const y=U(r*s*h),w=U(o*s*f),p=w+y,b=d+u,x=w-y,E=U(p*l),m=U(b*x),B=U(p*x),P=U(l*b);return new ExtendedPoint(E,m,P,B)}subtract(t){return this.add(t.negate())}precomputeWindow(t){const e=1+256/t,n=[];let r=this,i=r;for(let o=0;o<e;o++){i=r,n.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(r),n.push(i);r=i.double()}return n}wNAF(t,e){!e&&this.equals(ExtendedPoint.BASE)&&(e=Point.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&x.get(e);r||(r=this.precomputeWindow(n),e&&1!==n&&(r=ExtendedPoint.normalizeZ(r),x.set(e,r)));let i=ExtendedPoint.ZERO,s=ExtendedPoint.ZERO;const a=1+256/n,c=2**(n-1),f=BigInt(2**n-1),h=2**n,u=BigInt(n);for(let e=0;e<a;e++){const n=e*c;let a=Number(t&f);if(t>>=u,a>c&&(a-=h,t+=o),0===a){let t=r[n];e%2&&(t=t.negate()),s=s.add(t)}else{let t=r[n+Math.abs(a)-1];a<0&&(t=t.negate()),i=i.add(t)}}return ExtendedPoint.normalizeZ([i,s])[0]}multiply(t,e){return this.wNAF(N(t,f.l),e)}multiplyUnsafe(t){let e=N(t,f.l,!1);const n=ExtendedPoint.BASE,r=ExtendedPoint.ZERO;if(e===i)return r;if(this.equals(r)||e===o)return this;if(this.equals(n))return this.wNAF(e);let s=r,a=this;for(;e>i;)e&o&&(s=s.add(a)),a=a.double(),e>>=o;return s}isSmallOrder(){return this.multiplyUnsafe(f.h).equals(ExtendedPoint.ZERO)}isTorsionFree(){return this.multiplyUnsafe(f.l).equals(ExtendedPoint.ZERO)}toAffine(t=R(this.z)){const{x:e,y:n,z:r}=this,i=U(e*t),s=U(n*t);if(U(r*t)!==o)throw new Error("invZ was invalid");return new Point(i,s)}fromRistrettoBytes(){b()}toRistrettoBytes(){b()}fromRistrettoHash(){b()}}function g(t){if(!(t instanceof ExtendedPoint))throw new TypeError("ExtendedPoint expected")}function p(t){if(!(t instanceof RistrettoPoint))throw new TypeError("RistrettoPoint expected")}function b(){throw new Error("Legacy method: switch to RistrettoPoint")}ExtendedPoint.BASE=new ExtendedPoint(f.Gx,f.Gy,o,U(f.Gx*f.Gy)),ExtendedPoint.ZERO=new ExtendedPoint(i,o,o,i);class RistrettoPoint{constructor(t){this.ep=t}static calcElligatorRistrettoMap(t){const{d:e}=f,n=U(u*t*t),r=U((n+o)*y);let i=BigInt(-1);const s=U((i-e*n)*U(n+e));let{isValid:a,value:c}=k(r,s),h=U(c*t);v(h)||(h=U(-h)),a||(c=h),a||(i=n);const l=U(i*(n-o)*w-s),g=c*c,p=U((c+c)*s),b=U(l*d),x=U(o-g),E=U(o+g);return new ExtendedPoint(U(p*E),U(x*b),U(b*E),U(p*x))}static hashToCurve(t){const e=I((t=_(t,64)).slice(0,32)),n=this.calcElligatorRistrettoMap(e),r=I(t.slice(32,64)),i=this.calcElligatorRistrettoMap(r);return new RistrettoPoint(n.add(i))}static fromHex(t){t=_(t,32);const{a:e,d:n}=f,r="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",s=I(t);if(!function(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}(S(s),t)||v(s))throw new Error(r);const a=U(s*s),c=U(o+e*a),h=U(o-e*a),u=U(c*c),d=U(h*h),l=U(e*n*u-d),{isValid:y,value:w}=O(U(l*d)),g=U(w*h),p=U(w*g*l);let b=U((s+s)*g);v(b)&&(b=U(-b));const x=U(c*p),E=U(b*x);if(!y||v(E)||x===i)throw new Error(r);return new RistrettoPoint(new ExtendedPoint(b,x,o,E))}toRawBytes(){let{x:t,y:e,z:n,t:r}=this.ep;const i=U(U(n+e)*U(n-e)),o=U(t*e),{value:a}=O(U(i*o**s)),c=U(a*i),f=U(a*o),h=U(c*f*r);let d;if(v(r*h)){let n=U(e*u),r=U(t*u);t=n,e=r,d=U(c*l)}else d=f;v(t*h)&&(e=U(-e));let y=U((n-e)*d);return v(y)&&(y=U(-y)),S(y)}toHex(){return B(this.toRawBytes())}toString(){return this.toHex()}equals(t){p(t);const e=this.ep,n=t.ep,r=U(e.x*n.y)===U(e.y*n.x),i=U(e.y*n.y)===U(e.x*n.x);return r||i}add(t){return p(t),new RistrettoPoint(this.ep.add(t.ep))}subtract(t){return p(t),new RistrettoPoint(this.ep.subtract(t.ep))}multiply(t){return new RistrettoPoint(this.ep.multiply(t))}multiplyUnsafe(t){return new RistrettoPoint(this.ep.multiplyUnsafe(t))}}RistrettoPoint.BASE=new RistrettoPoint(ExtendedPoint.BASE),RistrettoPoint.ZERO=new RistrettoPoint(ExtendedPoint.ZERO);const x=new WeakMap;class Point{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,x.delete(this)}static fromHex(t,e=!0){const{d:n,P:r}=f,i=(t=_(t,32)).slice();i[31]=-129&t[31];const s=H(i);if(e&&s>=r)throw new Error("Expected 0 < hex < P");if(!e&&s>=h)throw new Error("Expected 0 < hex < 2**256");const a=U(s*s),c=U(a-o),u=U(n*a+o);let{isValid:d,value:l}=k(c,u);if(!d)throw new Error("Point.fromHex: invalid y coordinate");const y=(l&o)===o;return 0!=(128&t[31])!==y&&(l=U(-l)),new Point(l,s)}static async fromPrivateKey(t){return(await M(t)).point}toRawBytes(){const t=S(this.y);return t[31]|=this.x&o?128:0,t}toHex(){return B(this.toRawBytes())}toX25519(){const{y:t}=this;return S(U((o+t)*R(o-t)))}isTorsionFree(){return ExtendedPoint.fromAffine(this).isTorsionFree()}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new Point(U(-this.x),this.y)}add(t){return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return ExtendedPoint.fromAffine(this).multiply(t,this).toAffine()}}Point.BASE=new Point(f.Gx,f.Gy),Point.ZERO=new Point(i,o);class Signature{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=_(t,64),n=Point.fromHex(e.slice(0,32),!1),r=H(e.slice(32,64));return new Signature(n,r)}assertValidity(){const{r:t,s:e}=this;if(!(t instanceof Point))throw new Error("Expected Point instance");return N(e,f.l,!1),this}toRawBytes(){const t=new Uint8Array(64);return t.set(this.r.toRawBytes()),t.set(S(this.s),32),t}toHex(){return B(this.toRawBytes())}}function E(...t){if(!t.every(t=>t instanceof Uint8Array))throw new Error("Expected Uint8Array list");if(1===t.length)return t[0];const e=t.reduce((t,e)=>t+e.length,0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}const m=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function B(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=m[t[n]];return e}function P(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[n]=o}return e}function A(t){return P(t.toString(16).padStart(64,"0"))}function S(t){return A(t).reverse()}function v(t){return(U(t)&o)===o}function H(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+B(Uint8Array.from(t).reverse()))}function I(t){return U(H(t)&s**a-o)}function U(t,e=f.P){const n=t%e;return n>=i?n:e+n}function R(t,e=f.P){if(t===i||e<=i)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=U(t,e),r=e,s=i,a=o,c=o,h=i;for(;n!==i;){const t=r/n,e=r%n,i=s-c*t,o=a-h*t;r=n,n=e,s=c,a=h,c=i,h=o}if(r!==o)throw new Error("invert: does not exist");return U(s,e)}function T(t,e){const{P:n}=f;let r=t;for(;e-- >i;)r*=r,r%=n;return r}function L(t){const{P:e}=f,n=BigInt(5),r=BigInt(10),i=BigInt(20),a=BigInt(40),c=BigInt(80),h=t*t%e*t%e,u=T(h,s)*h%e,d=T(u,o)*t%e,l=T(d,n)*d%e,y=T(l,r)*l%e,w=T(y,i)*y%e,g=T(w,a)*w%e,p=T(g,c)*g%e,b=T(p,c)*g%e,x=T(b,r)*l%e;return{pow_p_5_8:T(x,s)*t%e,b2:h}}function k(t,e){const n=U(e*e*e),r=U(n*n*e);let i=U(t*n*L(t*r).pow_p_5_8);const o=U(e*i*i),s=i,a=U(i*u),c=o===t,f=o===U(-t),h=o===U(-t*u);return c&&(i=s),(f||h)&&(i=a),v(i)&&(i=U(-i)),{isValid:c||f,value:i}}function O(t){return k(o,t)}function C(t){return U(H(t),f.l)}function _(t,e){const n=t instanceof Uint8Array?Uint8Array.from(t):P(t);if("number"==typeof e&&n.length!==e)throw new Error(`Expected ${e} bytes`);return n}function N(t,e,n=!0){if(!e)throw new TypeError("Specify max value");if("number"==typeof t&&Number.isSafeInteger(t)&&(t=BigInt(t)),"bigint"==typeof t&&t<e)if(n){if(i<t)return t}else if(i<=t)return t;throw new TypeError("Expected valid scalar: 0 < scalar < max")}function D(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}function z(t){if(32!==(t="bigint"==typeof t||"number"==typeof t?A(N(t,h)):_(t)).length)throw new Error("Expected 32 bytes");return t}function G(t){const e=D(t.slice(0,32)),n=t.slice(32,64),r=C(e),i=Point.BASE.multiply(r),o=i.toRawBytes();return{head:e,prefix:n,scalar:r,point:i,pointBytes:o}}let J;function F(...t){if("function"!=typeof J)throw new Error("utils.sha512Sync must be set to use sync methods");return J(...t)}async function M(t){return G(await et.sha512(z(t)))}function V(t){return G(F(z(t)))}async function Z(t){return(await M(t)).pointBytes}async function j(t,e){t=_(t);const{prefix:n,scalar:r,pointBytes:i}=await M(e),o=C(await et.sha512(n,t)),s=Point.BASE.multiply(o),a=U(o+C(await et.sha512(s.toRawBytes(),i,t))*r,f.l);return new Signature(s,a).toRawBytes()}function W(t,e,n){e=_(e),n instanceof Point||(n=Point.fromHex(n,!1));const{r:r,s:i}=t instanceof Signature?t.assertValidity():Signature.fromHex(t);return{r:r,s:i,SB:ExtendedPoint.BASE.multiplyUnsafe(i),pub:n,msg:e}}function K(t,e,n,r){const i=C(r),o=ExtendedPoint.fromAffine(t).multiplyUnsafe(i);return ExtendedPoint.fromAffine(e).add(o).subtract(n).multiplyUnsafe(f.h).equals(ExtendedPoint.ZERO)}async function $(t,e,n){const{r:r,SB:i,msg:o,pub:s}=W(t,e,n),a=await et.sha512(r.toRawBytes(),s.toRawBytes(),o);return K(s,r,i,a)}const q={getExtendedPublicKey:V,getPublicKey:function(t){return V(t).pointBytes},sign:function(t,e){t=_(t);const{prefix:n,scalar:r,pointBytes:i}=V(e),o=C(F(n,t)),s=Point.BASE.multiply(o),a=U(o+C(F(s.toRawBytes(),i,t))*r,f.l);return new Signature(s,a).toRawBytes()},verify:function(t,e,n){const{r:r,SB:i,msg:o,pub:s}=W(t,e,n),a=F(r.toRawBytes(),s.toRawBytes(),o);return K(s,r,i,a)}};async function X(t,e){const{head:n}=await M(t),r=Point.fromHex(e).toX25519();return Y.scalarMult(n,r)}function Q(t,e,n){const r=U(t*(e-n));return[e=U(e-r),n=U(n+r)]}Point.BASE._setWindowSize(8);const Y={BASE_POINT_U:"0900000000000000000000000000000000000000000000000000000000000000",scalarMult(t,e){const n=function(t,e){const{P:n}=f,r=N(t,n),a=N(e,n),c=BigInt(121665),h=r;let u,d=o,l=i,y=r,w=o,g=i;for(let t=BigInt(254);t>=i;t--){const e=a>>t&o;g^=e,u=Q(g,d,y),d=u[0],y=u[1],u=Q(g,l,w),l=u[0],w=u[1],g=e;const n=d+l,r=U(n*n),i=d-l,f=U(i*i),p=r-f,b=y+w,x=U((y-w)*n),E=U(b*i);y=U((x+E)**s),w=U(h*(x-E)**s),d=U(r*f),l=U(p*(r+U(c*p)))}u=Q(g,d,y),d=u[0],y=u[1],u=Q(g,l,w),l=u[0],w=u[1];const{pow_p_5_8:p,b2:b}=L(l),x=U(T(p,BigInt(3))*b);return U(d*x)}(function(t){const e=_(t,32);return e[31]&=127,H(e)}(e),H(D(_(t,32))));if(n===i)throw new Error("Invalid private or public key received");return function(t){return S(U(t,f.P))}(n)},scalarMultBase:t=>Y.scalarMult(t,Y.BASE_POINT_U)},tt={node:r,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},et={TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],bytesToHex:B,hexToBytes:P,concatBytes:E,getExtendedPublicKey:M,mod:U,invert:R,hashToPrivateScalar:t=>{if((t=_(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return U(H(t),f.l-o)+o},randomBytes:(t=32)=>{if(tt.web)return tt.web.getRandomValues(new Uint8Array(t));if(tt.node){const{randomBytes:e}=tt.node;return new Uint8Array(e(t).buffer)}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>et.randomBytes(32),sha512:async(...t)=>{const e=E(...t);if(tt.web){const t=await tt.web.subtle.digest("SHA-512",e.buffer);return new Uint8Array(t)}if(tt.node)return Uint8Array.from(tt.node.createHash("sha512").update(e).digest());throw new Error("The environment doesn't have sha512 function")},precompute(t=8,e=Point.BASE){const n=e.equals(Point.BASE)?e:new Point(e.x,e.y);return n._setWindowSize(t),n.multiply(s),n},sha512Sync:void 0};Object.defineProperties(et,{sha512Sync:{configurable:!1,get:()=>J,set(t){J||(J=t)}}})},2876:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto={node:void 0,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0}},2877:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.add=e.toBig=e.split=e.fromBig=void 0;const r=BigInt(2**32-1),i=BigInt(32);function o(t,e=!1){return e?{h:Number(t&r),l:Number(t>>i&r)}:{h:0|Number(t>>i&r),l:0|Number(t&r)}}function s(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let i=0;i<t.length;i++){const{h:s,l:a}=o(t[i],e);[n[i],r[i]]=[s,a]}return[n,r]}e.fromBig=o,e.split=s;e.toBig=(t,e)=>BigInt(t>>>0)<<i|BigInt(e>>>0);function a(t,e,n,r){const i=(e>>>0)+(r>>>0);return{h:t+n+(i/2**32|0)|0,l:0|i}}e.add=a;const c={fromBig:o,split:s,toBig:e.toBig,shrSH:(t,e,n)=>t>>>n,shrSL:(t,e,n)=>t<<32-n|e>>>n,rotrSH:(t,e,n)=>t>>>n|e<<32-n,rotrSL:(t,e,n)=>t<<32-n|e>>>n,rotrBH:(t,e,n)=>t<<64-n|e>>>n-32,rotrBL:(t,e,n)=>t>>>n-32|e<<64-n,rotr32H:(t,e)=>e,rotr32L:(t,e)=>t,rotlSH:(t,e,n)=>t<<n|e>>>32-n,rotlSL:(t,e,n)=>e<<n|t>>>32-n,rotlBH:(t,e,n)=>e<<n-32|t>>>64-n,rotlBL:(t,e,n)=>t<<n-32|e>>>64-n,add:a,add3L:(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),add3H:(t,e,n,r)=>e+n+r+(t/2**32|0)|0,add4L:(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),add4H:(t,e,n,r,i)=>e+n+r+i+(t/2**32|0)|0,add5H:(t,e,n,r,i,o)=>e+n+r+i+o+(t/2**32|0)|0,add5L:(t,e,n,r,i)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(i>>>0)};e.default=c},3400:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.ripemd160=e.RIPEMD160=void 0;const r=n(791),i=n(443),o=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),s=Uint8Array.from({length:16},(t,e)=>e),a=s.map(t=>(9*t+5)%16);let c=[s],f=[a];for(let t=0;t<4;t++)for(let e of[c,f])e.push(e[t].map(t=>o[t]));const h=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map(t=>new Uint8Array(t)),u=c.map((t,e)=>t.map(t=>h[e][t])),d=f.map((t,e)=>t.map(t=>h[e][t])),l=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),y=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),w=(t,e)=>t<<e|t>>>32-e;function g(t,e,n,r){return 0===t?e^n^r:1===t?e&n|~e&r:2===t?(e|~n)^r:3===t?e&r|n&~r:e^(n|~r)}const p=new Uint32Array(16);class RIPEMD160 extends r.SHA2{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:t,h1:e,h2:n,h3:r,h4:i}=this;return[t,e,n,r,i]}set(t,e,n,r,i){this.h0=0|t,this.h1=0|e,this.h2=0|n,this.h3=0|r,this.h4=0|i}process(t,e){for(let n=0;n<16;n++,e+=4)p[n]=t.getUint32(e,!0);let n=0|this.h0,r=n,i=0|this.h1,o=i,s=0|this.h2,a=s,h=0|this.h3,b=h,x=0|this.h4,E=x;for(let t=0;t<5;t++){const e=4-t,m=l[t],B=y[t],P=c[t],A=f[t],S=u[t],v=d[t];for(let e=0;e<16;e++){const r=w(n+g(t,i,s,h)+p[P[e]]+m,S[e])+x|0;n=x,x=h,h=0|w(s,10),s=i,i=r}for(let t=0;t<16;t++){const n=w(r+g(e,o,a,b)+p[A[t]]+B,v[t])+E|0;r=E,E=b,b=0|w(a,10),a=o,o=n}}this.set(this.h1+s+b|0,this.h2+h+E|0,this.h3+x+r|0,this.h4+n+o|0,this.h0+i+a|0)}roundClean(){p.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}e.RIPEMD160=RIPEMD160,e.ripemd160=(0,i.wrapConstructor)(()=>new RIPEMD160)},379:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sha256=void 0;const r=n(791),i=n(443),o=(t,e,n)=>t&e^t&n^e&n,s=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),a=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),c=new Uint32Array(64);class SHA256 extends r.SHA2{constructor(){super(64,32,8,!1),this.A=0|a[0],this.B=0|a[1],this.C=0|a[2],this.D=0|a[3],this.E=0|a[4],this.F=0|a[5],this.G=0|a[6],this.H=0|a[7]}get(){const{A:t,B:e,C:n,D:r,E:i,F:o,G:s,H:a}=this;return[t,e,n,r,i,o,s,a]}set(t,e,n,r,i,o,s,a){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(t,e){for(let n=0;n<16;n++,e+=4)c[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=c[t-15],n=c[t-2],r=(0,i.rotr)(e,7)^(0,i.rotr)(e,18)^e>>>3,o=(0,i.rotr)(n,17)^(0,i.rotr)(n,19)^n>>>10;c[t]=o+c[t-7]+r+c[t-16]|0}let{A:n,B:r,C:a,D:f,E:h,F:u,G:d,H:l}=this;for(let t=0;t<64;t++){const e=l+((0,i.rotr)(h,6)^(0,i.rotr)(h,11)^(0,i.rotr)(h,25))+((y=h)&u^~y&d)+s[t]+c[t]|0,w=((0,i.rotr)(n,2)^(0,i.rotr)(n,13)^(0,i.rotr)(n,22))+o(n,r,a)|0;l=d,d=u,u=h,h=f+e|0,f=a,a=r,r=n,n=e+w|0}var y;n=n+this.A|0,r=r+this.B|0,a=a+this.C|0,f=f+this.D|0,h=h+this.E|0,u=u+this.F|0,d=d+this.G|0,l=l+this.H|0,this.set(n,r,a,f,h,u,d,l)}roundClean(){c.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}e.sha256=(0,i.wrapConstructor)(()=>new SHA256)},390:function(t,e,n){"use strict";n.r(e),n.d(e,"CURVE",(function(){return h})),n.d(e,"Point",(function(){return Point})),n.d(e,"Signature",(function(){return Signature})),n.d(e,"getPublicKey",(function(){return J})),n.d(e,"recoverPublicKey",(function(){return F})),n.d(e,"getSharedSecret",(function(){return V})),n.d(e,"sign",(function(){return q})),n.d(e,"signSync",(function(){return X})),n.d(e,"verify",(function(){return Y})),n.d(e,"schnorr",(function(){return ht})),n.d(e,"utils",(function(){return yt}));var r=n(27);const i=BigInt(0),o=BigInt(1),s=BigInt(2),a=BigInt(3),c=BigInt(8),f=s**BigInt(256),h={a:i,b:BigInt(7),P:f-s**BigInt(32)-BigInt(977),n:f-BigInt("432420386565659656852420866394968145599"),h:o,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")};function u(t){const{a:e,b:n}=h,r=I(t*t),i=I(r*t);return I(i+e*t+n)}const d=h.a===i;class JacobianPoint{constructor(t,e,n){this.x=t,this.y=e,this.z=n}static fromAffine(t){if(!(t instanceof Point))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new JacobianPoint(t.x,t.y,o)}static toAffineBatch(t){const e=function(t,e=h.P){const n=new Array(t.length),r=R(t.reduce((t,r,o)=>r===i?t:(n[o]=t,I(t*r,e)),o),e);return t.reduceRight((t,r,o)=>r===i?t:(n[o]=I(t*n[o],e),I(t*r,e)),r),n}(t.map(t=>t.z));return t.map((t,n)=>t.toAffine(e[n]))}static normalizeZ(t){return JacobianPoint.toAffineBatch(t).map(JacobianPoint.fromAffine)}equals(t){if(!(t instanceof JacobianPoint))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:i,y:o,z:a}=t,c=I(r**s),f=I(a**s),h=I(e*f),u=I(i*c),d=I(I(n*a)*f),l=I(I(o*r)*c);return h===u&&d===l}negate(){return new JacobianPoint(this.x,I(-this.y),this.z)}double(){const{x:t,y:e,z:n}=this,r=I(t**s),i=I(e**s),o=I(i**s),f=I(s*(I((t+i)**s)-r-o)),h=I(a*r),u=I(h**s),d=I(u-s*f),l=I(h*(f-d)-c*o),y=I(s*e*n);return new JacobianPoint(d,l,y)}add(t){if(!(t instanceof JacobianPoint))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:o,y:a,z:c}=t;if(o===i||a===i)return this;if(e===i||n===i)return t;const f=I(r**s),h=I(c**s),u=I(e*h),d=I(o*f),l=I(I(n*c)*h),y=I(I(a*r)*f),w=I(d-u),g=I(y-l);if(w===i)return g===i?this.double():JacobianPoint.ZERO;const p=I(w**s),b=I(w*p),x=I(u*p),E=I(g**s-b-s*x),m=I(g*(x-E)-l*b),B=I(r*c*w);return new JacobianPoint(E,m,B)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=JacobianPoint.ZERO;if("bigint"==typeof t&&t===i)return e;let n=H(t);if(n===o)return this;if(!d){let t=e,r=this;for(;n>i;)n&o&&(t=t.add(r)),r=r.double(),n>>=o;return t}let{k1neg:r,k1:s,k2neg:a,k2:c}=k(n),f=e,u=e,l=this;for(;s>i||c>i;)s&o&&(f=f.add(l)),c&o&&(u=u.add(l)),l=l.double(),s>>=o,c>>=o;return r&&(f=f.negate()),a&&(u=u.negate()),u=new JacobianPoint(I(u.x*h.beta),u.y,u.z),f.add(u)}precomputeWindow(t){const e=d?128/t+1:256/t+1,n=[];let r=this,i=r;for(let o=0;o<e;o++){i=r,n.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(r),n.push(i);r=i.double()}return n}wNAF(t,e){!e&&this.equals(JacobianPoint.BASE)&&(e=Point.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let r=e&&l.get(e);r||(r=this.precomputeWindow(n),e&&1!==n&&(r=JacobianPoint.normalizeZ(r),l.set(e,r)));let i=JacobianPoint.ZERO,s=JacobianPoint.ZERO;const a=1+(d?128/n:256/n),c=2**(n-1),f=BigInt(2**n-1),h=2**n,u=BigInt(n);for(let e=0;e<a;e++){const n=e*c;let a=Number(t&f);if(t>>=u,a>c&&(a-=h,t+=o),0===a){let t=r[n];e%2&&(t=t.negate()),s=s.add(t)}else{let t=r[n+Math.abs(a)-1];a<0&&(t=t.negate()),i=i.add(t)}}return{p:i,f:s}}multiply(t,e){let n,r,i=H(t);if(d){const{k1neg:t,k1:o,k2neg:s,k2:a}=k(i);let{p:c,f:f}=this.wNAF(o,e),{p:u,f:d}=this.wNAF(a,e);t&&(c=c.negate()),s&&(u=u.negate()),u=new JacobianPoint(I(u.x*h.beta),u.y,u.z),n=c.add(u),r=f.add(d)}else{const{p:t,f:o}=this.wNAF(i,e);n=t,r=o}return JacobianPoint.normalizeZ([n,r])[0]}toAffine(t=R(this.z)){const{x:e,y:n,z:r}=this,i=t,s=I(i*i),a=I(s*i),c=I(e*s),f=I(n*a);if(I(r*i)!==o)throw new Error("invZ was invalid");return new Point(c,f)}}JacobianPoint.BASE=new JacobianPoint(h.Gx,h.Gy,o),JacobianPoint.ZERO=new JacobianPoint(i,o,i);const l=new WeakMap;class Point{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,l.delete(this)}static fromCompressedHex(t){const e=32===t.length,n=S(e?t:t.subarray(1));if(!_(n))throw new Error("Point is not on curve");let r=function(t){const{P:e}=h,n=BigInt(6),r=BigInt(11),i=BigInt(22),o=BigInt(23),c=BigInt(44),f=BigInt(88),u=t*t*t%e,d=u*u*t%e,l=U(d,a)*d%e,y=U(l,a)*d%e,w=U(y,s)*u%e,g=U(w,r)*w%e,p=U(g,i)*g%e,b=U(p,c)*p%e,x=U(b,f)*b%e,E=U(x,c)*p%e,m=U(E,a)*d%e,B=U(m,o)*g%e,P=U(B,n)*u%e;return U(P,s)}(u(n));const i=(r&o)===o;if(e)i&&(r=I(-r));else{1==(1&t[0])!==i&&(r=I(-r))}const c=new Point(n,r);return c.assertValidity(),c}static fromUncompressedHex(t){const e=S(t.subarray(1,33)),n=S(t.subarray(33,65)),r=new Point(e,n);return r.assertValidity(),r}static fromHex(t){const e=v(t),n=e.length,r=e[0];if(32===n||33===n&&(2===r||3===r))return this.fromCompressedHex(e);if(65===n&&4===r)return this.fromUncompressedHex(e);throw new Error("Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not "+n)}static fromPrivateKey(t){return Point.BASE.multiply(D(t))}static fromSignature(t,e,n){const r=O(t=v(t)),{r:i,s:o}=G(e);if(0!==n&&1!==n)throw new Error("Cannot recover signature: invalid recovery bit");const s=1&n?"03":"02",a=Point.fromHex(s+E(i)),{n:c}=h,f=R(i,c),u=I(-r*f,c),d=I(o*f,c),l=Point.BASE.multiplyAndAddUnsafe(a,u,d);if(!l)throw new Error("Cannot recover signature: point at infinify");return l.assertValidity(),l}toRawBytes(t=!1){return A(this.toHex(t))}toHex(t=!1){const e=E(this.x);if(t){return`${this.y&o?"03":"02"}${e}`}return`04${e}${E(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:n}=this;if(!_(e)||!_(n))throw new Error(t);const r=I(n*n);if(I(r-u(e))!==i)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new Point(this.x,I(-this.y))}double(){return JacobianPoint.fromAffine(this).double().toAffine()}add(t){return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return JacobianPoint.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,n){const r=JacobianPoint.fromAffine(this),s=e===i||e===o||this!==Point.BASE?r.multiplyUnsafe(e):r.multiply(e),a=JacobianPoint.fromAffine(t).multiplyUnsafe(n),c=s.add(a);return c.equals(JacobianPoint.ZERO)?void 0:c.toAffine()}}function y(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function w(t){if(t.length<2||2!==t[0])throw new Error("Invalid signature integer tag: "+x(t));const e=t[1],n=t.subarray(2,e+2);if(!e||n.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===n[0]&&n[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:S(n),left:t.subarray(e+2)}}Point.BASE=new Point(h.Gx,h.Gy),Point.ZERO=new Point(i,i);class Signature{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=p(t),n="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(n+": Expected string or Uint8Array");const r=e?x(t):t;if(128!==r.length)throw new Error(n+": Expected 64-byte hex");return new Signature(P(r.slice(0,64)),P(r.slice(64,128)))}static fromDER(t){const e=p(t);if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:n,s:r}=function(t){if(t.length<2||48!=t[0])throw new Error("Invalid signature tag: "+x(t));if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:n}=w(t.subarray(2)),{data:r,left:i}=w(n);if(i.length)throw new Error("Invalid signature: left bytes after parsing: "+x(i));return{r:e,s:r}}(e?t:A(t));return new Signature(n,r)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!C(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!C(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const t=h.n>>o;return this.s>t}normalizeS(){return this.hasHighS()?new Signature(this.r,h.n-this.s):this}toDERRawBytes(t=!1){return A(this.toDERHex(t))}toDERHex(t=!1){const e=y(B(this.s));if(t)return e;const n=y(B(this.r)),r=B(n.length/2),i=B(e.length/2);return`30${B(n.length/2+e.length/2+4)}02${r}${n}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return A(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}function g(...t){if(!t.every(p))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce((t,e)=>t+e.length,0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}function p(t){return t instanceof Uint8Array}const b=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function x(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let n=0;n<t.length;n++)e+=b[t[n]];return e}function E(t){if(t>f)throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function m(t){return A(E(t))}function B(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function P(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt("0x"+t)}function A(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[n]=o}return e}function S(t){return P(x(t))}function v(t){return t instanceof Uint8Array?Uint8Array.from(t):A(t)}function H(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&C(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function I(t,e=h.P){const n=t%e;return n>=i?n:e+n}function U(t,e){const{P:n}=h;let r=t;for(;e-- >i;)r*=r,r%=n;return r}function R(t,e=h.P){if(t===i||e<=i)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=I(t,e),r=e,s=i,a=o,c=o,f=i;for(;n!==i;){const t=r/n,e=r%n,i=s-c*t,o=a-f*t;r=n,n=e,s=c,a=f,c=i,f=o}if(r!==o)throw new Error("invert: does not exist");return I(s,e)}const T=(t,e)=>(t+e/s)/e,L=s**BigInt(128);function k(t){const{n:e}=h,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-o*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,a=T(s*t,e),c=T(-r*t,e);let f=I(t-a*n-c*i,e),u=I(-a*r-c*s,e);const d=f>L,l=u>L;if(d&&(f=e-f),l&&(u=e-u),f>L||u>L)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:d,k1:f,k2neg:l,k2:u}}function O(t){const{n:e}=h,n=8*t.length-256;let r=S(t);return n>0&&(r>>=BigInt(n)),r>=e&&(r-=e),r}class HmacDrbg{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return yt.hmacSha256(this.k,...t)}hmacSync(...t){if("function"!=typeof yt.hmacSha256Sync)throw new Error("utils.hmacSha256Sync is undefined, you need to set it");const e=yt.hmacSha256Sync(this.k,...t);if(e instanceof Promise)throw new Error("To use sync sign(), ensure utils.hmacSha256 is sync");return e}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.incr(),this.v=this.hmacSync(this.v),this.v}}function C(t){return i<t&&t<h.n}function _(t){return i<t&&t<h.P}function N(t,e,n){const r=S(t);if(!C(r))return;const{n:s}=h,a=Point.BASE.multiply(r),c=I(a.x,s);if(c===i)return;const f=I(R(r,s)*I(e+n*c,s),s);if(f===i)return;const u=new Signature(c,f);return{sig:u,recovery:(a.x===u.r?0:2)|Number(a.y&o)}}function D(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=P(t)}else{if(!p(t))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=S(t)}if(!C(e))throw new Error("Expected private key: 0 < key < n");return e}function z(t){return t instanceof Point?(t.assertValidity(),t):Point.fromHex(t)}function G(t){if(t instanceof Signature)return t.assertValidity(),t;try{return Signature.fromDER(t)}catch(e){return Signature.fromCompact(t)}}function J(t,e=!1){return Point.fromPrivateKey(t).toRawBytes(e)}function F(t,e,n,r=!1){return Point.fromSignature(t,e,n).toRawBytes(r)}function M(t){const e=p(t),n="string"==typeof t,r=(e||n)&&t.length;return e?33===r||65===r:n?66===r||130===r:t instanceof Point}function V(t,e,n=!1){if(M(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!M(e))throw new TypeError("getSharedSecret: second arg must be public key");const r=z(e);return r.assertValidity(),r.multiply(D(t)).toRawBytes(n)}function Z(t){return S(t.length>32?t.slice(0,32):t)}function j(t){const e=Z(t),n=I(e,h.n);return W(n<i?e:n)}function W(t){if("bigint"!=typeof t)throw new Error("Expected bigint");return A(E(t))}function K(t,e,n){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const r=v(t),i=D(e),o=[W(i),j(r)];if(null!=n){!0===n&&(n=yt.randomBytes(32));const t=v(n);if(32!==t.length)throw new Error("sign: Expected 32 bytes of extra data");o.push(t)}return{seed:g(...o),m:Z(r),d:i}}function $(t,e){let{sig:n,recovery:r}=t;const{canonical:i,der:o,recovered:s}=Object.assign({canonical:!0,der:!0},e);i&&n.hasHighS()&&(n=n.normalizeS(),r^=1);const a=o?n.toDERRawBytes():n.toCompactRawBytes();return s?[a,r]:a}async function q(t,e,n={}){const{seed:r,m:i,d:o}=K(t,e,n.extraEntropy);let s;const a=new HmacDrbg;for(await a.reseed(r);!(s=N(await a.generate(),i,o));)await a.reseed();return $(s,n)}function X(t,e,n={}){const{seed:r,m:i,d:o}=K(t,e,n.extraEntropy);let s;const a=new HmacDrbg;for(a.reseedSync(r);!(s=N(a.generateSync(),i,o));)a.reseedSync();return $(s,n)}const Q={strict:!0};function Y(t,e,n,r=Q){let i;try{i=G(t),e=v(e)}catch(t){return!1}const{r:o,s:s}=i;if(r.strict&&i.hasHighS())return!1;const a=O(e);let c;try{c=z(n)}catch(t){return!1}const{n:f}=h,u=R(s,f),d=I(a*u,f),l=I(o*u,f),y=Point.BASE.multiplyAndAddUnsafe(c,d,l);if(!y)return!1;return I(y.x,f)===o}function tt(t){return I(S(t),h.n)}function et(t){return(t.y&o)===i}class SchnorrSignature{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=v(t);if(64!==e.length)throw new TypeError("SchnorrSignature.fromHex: expected 64 bytes, not "+e.length);const n=S(e.subarray(0,32)),r=S(e.subarray(32,64));return new SchnorrSignature(n,r)}assertValidity(){const{r:t,s:e}=this;if(!_(t)||!C(e))throw new Error("Invalid signature")}toHex(){return E(this.r)+E(this.s)}toRawBytes(){return A(this.toHex())}}function nt(t,e,n){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);const r=v(t),i=D(e),o=v(n);if(32!==o.length)throw new TypeError("sign: Expected 32 bytes of aux randomness");const s=Point.fromPrivateKey(i),a=s.toRawX();return{m:r,P:s,px:a,d:et(s)?i:h.n-i,rand:o}}function rt(t,e){return m(t^S(e))}function it(t){const e=I(S(t),h.n);if(e===i)throw new Error("sign: Creation of signature failed. k is zero");const n=Point.fromPrivateKey(e),r=n.toRawX();return{R:n,rx:r,k:et(n)?e:h.n-e}}function ot(t,e,n,r){return new SchnorrSignature(t.x,I(e+n*r,h.n)).toRawBytes()}function st(t,e,n){const r=t instanceof SchnorrSignature,i=r?t:SchnorrSignature.fromHex(t);return r&&i.assertValidity(),{...i,m:v(e),P:z(n)}}function at(t,e,n,r){const i=Point.BASE.multiplyAndAddUnsafe(e,D(n),I(-r,h.n));return!(!i||!et(i)||i.x!==t)}async function ct(t,e,n){try{const{r:r,s:i,m:o,P:s}=st(t,e,n),a=tt(await yt.taggedHash(dt.challenge,m(r),s.toRawX(),o));return at(r,s,i,a)}catch(t){return!1}}function ft(t,e,n){try{const{r:r,s:i,m:o,P:s}=st(t,e,n),a=tt(yt.taggedHashSync(dt.challenge,m(r),s.toRawX(),o));return at(r,s,i,a)}catch(t){return!1}}const ht={Signature:SchnorrSignature,getPublicKey:function(t){return Point.fromPrivateKey(t).toRawX()},sign:async function(t,e,n=yt.randomBytes()){const{m:r,px:i,d:o,rand:s}=nt(t,e,n),a=rt(o,await yt.taggedHash(dt.aux,s)),{R:c,rx:f,k:h}=it(await yt.taggedHash(dt.nonce,a,i,r)),u=ot(c,h,tt(await yt.taggedHash(dt.challenge,f,i,r)),o);if(!await ct(u,r,i))throw new Error("sign: Invalid signature produced");return u},verify:ct,signSync:function(t,e,n=yt.randomBytes()){const{m:r,px:i,d:o,rand:s}=nt(t,e,n),a=rt(o,yt.taggedHashSync(dt.aux,s)),{R:c,rx:f,k:h}=it(yt.taggedHashSync(dt.nonce,a,i,r)),u=ot(c,h,tt(yt.taggedHashSync(dt.challenge,f,i,r)),o);if(!ft(u,r,i))throw new Error("sign: Invalid signature produced");return u},verifySync:ft};Point.BASE._setWindowSize(8);const ut={node:r,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},dt={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},lt={},yt={isValidPrivateKey(t){try{return D(t),!0}catch(t){return!1}},privateAdd:(t,e)=>m(I(D(t)+D(e),h.n)),privateNegate:t=>{const e=D(t);return m(h.n-e)},pointAddScalar:(t,e,n)=>{const r=Point.fromHex(t),i=D(e),s=Point.BASE.multiplyAndAddUnsafe(r,i,o);if(!s)throw new Error("Tweaked point at infinity");return s.toRawBytes(n)},pointMultiply:(t,e,n)=>{const r=Point.fromHex(t),i=S(v(e));return r.multiply(i).toRawBytes(n)},hashToPrivateKey:t=>{if((t=v(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return m(I(S(t),h.n-o)+o)},randomBytes:(t=32)=>{if(ut.web)return ut.web.getRandomValues(new Uint8Array(t));if(ut.node){const{randomBytes:e}=ut.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>yt.hashToPrivateKey(yt.randomBytes(40)),bytesToHex:x,hexToBytes:A,concatBytes:g,mod:I,invert:R,sha256:async(...t)=>{if(ut.web){const e=await ut.web.subtle.digest("SHA-256",g(...t));return new Uint8Array(e)}if(ut.node){const{createHash:e}=ut.node,n=e("sha256");return t.forEach(t=>n.update(t)),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(ut.web){const n=await ut.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=g(...e),i=await ut.web.subtle.sign("HMAC",n,r);return new Uint8Array(i)}if(ut.node){const{createHmac:n}=ut.node,r=n("sha256",t);return e.forEach(t=>r.update(t)),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...e)=>{let n=lt[t];if(void 0===n){const e=await yt.sha256(Uint8Array.from(t,t=>t.charCodeAt(0)));n=g(e,e),lt[t]=n}return yt.sha256(n,...e)},taggedHashSync:(t,...e)=>{if("function"!=typeof yt.sha256Sync)throw new Error("utils.sha256Sync is undefined, you need to set it");let n=lt[t];if(void 0===n){const e=yt.sha256Sync(Uint8Array.from(t,t=>t.charCodeAt(0)));n=g(e,e),lt[t]=n}return yt.sha256Sync(n,...e)},precompute(t=8,e=Point.BASE){const n=e===Point.BASE?e:new Point(e.x,e.y);return n._setWindowSize(t),n.multiply(a),n}}},443:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.isLE=e.rotr=e.createView=e.u32=e.u8=void 0;const r=n(2876);e.u8=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength);e.u32=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4));e.createView=t=>new DataView(t.buffer,t.byteOffset,t.byteLength);if(e.rotr=(t,e)=>t<<32-e|t>>>e,e.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],!e.isLE)throw new Error("Non little-endian hardware is not supported");const i=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));e.bytesToHex=function(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=i[t[n]];return e},e.hexToBytes=function(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[n]=o}return e};function o(t){if("string"!=typeof t)throw new TypeError("utf8ToBytes expected string, got "+typeof t);return(new TextEncoder).encode(t)}function s(t){if("string"==typeof t&&(t=o(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}e.nextTick=async()=>{},e.asyncLoop=async function(t,n,r){let i=Date.now();for(let o=0;o<t;o++){r(o);const t=Date.now()-i;t>=0&&t<n||(await(0,e.nextTick)(),i+=t)}},e.utf8ToBytes=o,e.toBytes=s,e.concatBytes=function(...t){if(!t.every(t=>t instanceof Uint8Array))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce((t,e)=>t+e.length,0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n};e.Hash=class Hash{clone(){return this._cloneInto()}};e.checkOpts=function(t,e){if(void 0!==e&&("object"!=typeof e||(n=e,"[object Object]"!==Object.prototype.toString.call(n)||n.constructor!==Object)))throw new TypeError("Options should be object or undefined");var n;return Object.assign(t,e)},e.wrapConstructor=function(t){const e=e=>t().update(s(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e},e.wrapConstructorWithOpts=function(t){const e=(e,n)=>t(n).update(s(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e},e.randomBytes=function(t=32){if(r.crypto.web)return r.crypto.web.getRandomValues(new Uint8Array(t));if(r.crypto.node)return new Uint8Array(r.crypto.node.randomBytes(t).buffer);throw new Error("The environment doesn't have randomBytes function")}},605:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.sha384=e.sha512_256=e.sha512=e.SHA512=void 0;const r=n(791),i=n(2877),o=n(443),[s,a]=i.default.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))),c=new Uint32Array(80),f=new Uint32Array(80);class SHA512 extends r.SHA2{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:t,Al:e,Bh:n,Bl:r,Ch:i,Cl:o,Dh:s,Dl:a,Eh:c,El:f,Fh:h,Fl:u,Gh:d,Gl:l,Hh:y,Hl:w}=this;return[t,e,n,r,i,o,s,a,c,f,h,u,d,l,y,w]}set(t,e,n,r,i,o,s,a,c,f,h,u,d,l,y,w){this.Ah=0|t,this.Al=0|e,this.Bh=0|n,this.Bl=0|r,this.Ch=0|i,this.Cl=0|o,this.Dh=0|s,this.Dl=0|a,this.Eh=0|c,this.El=0|f,this.Fh=0|h,this.Fl=0|u,this.Gh=0|d,this.Gl=0|l,this.Hh=0|y,this.Hl=0|w}process(t,e){for(let n=0;n<16;n++,e+=4)c[n]=t.getUint32(e),f[n]=t.getUint32(e+=4);for(let t=16;t<80;t++){const e=0|c[t-15],n=0|f[t-15],r=i.default.rotrSH(e,n,1)^i.default.rotrSH(e,n,8)^i.default.shrSH(e,n,7),o=i.default.rotrSL(e,n,1)^i.default.rotrSL(e,n,8)^i.default.shrSL(e,n,7),s=0|c[t-2],a=0|f[t-2],h=i.default.rotrSH(s,a,19)^i.default.rotrBH(s,a,61)^i.default.shrSH(s,a,6),u=i.default.rotrSL(s,a,19)^i.default.rotrBL(s,a,61)^i.default.shrSL(s,a,6),d=i.default.add4L(o,u,f[t-7],f[t-16]),l=i.default.add4H(d,r,h,c[t-7],c[t-16]);c[t]=0|l,f[t]=0|d}let{Ah:n,Al:r,Bh:o,Bl:h,Ch:u,Cl:d,Dh:l,Dl:y,Eh:w,El:g,Fh:p,Fl:b,Gh:x,Gl:E,Hh:m,Hl:B}=this;for(let t=0;t<80;t++){const e=i.default.rotrSH(w,g,14)^i.default.rotrSH(w,g,18)^i.default.rotrBH(w,g,41),P=i.default.rotrSL(w,g,14)^i.default.rotrSL(w,g,18)^i.default.rotrBL(w,g,41),A=w&p^~w&x,S=g&b^~g&E,v=i.default.add5L(B,P,S,a[t],f[t]),H=i.default.add5H(v,m,e,A,s[t],c[t]),I=0|v,U=i.default.rotrSH(n,r,28)^i.default.rotrBH(n,r,34)^i.default.rotrBH(n,r,39),R=i.default.rotrSL(n,r,28)^i.default.rotrBL(n,r,34)^i.default.rotrBL(n,r,39),T=n&o^n&u^o&u,L=r&h^r&d^h&d;m=0|x,B=0|E,x=0|p,E=0|b,p=0|w,b=0|g,({h:w,l:g}=i.default.add(0|l,0|y,0|H,0|I)),l=0|u,y=0|d,u=0|o,d=0|h,o=0|n,h=0|r;const k=i.default.add3L(I,R,L);n=i.default.add3H(k,H,U,T),r=0|k}({h:n,l:r}=i.default.add(0|this.Ah,0|this.Al,0|n,0|r)),({h:o,l:h}=i.default.add(0|this.Bh,0|this.Bl,0|o,0|h)),({h:u,l:d}=i.default.add(0|this.Ch,0|this.Cl,0|u,0|d)),({h:l,l:y}=i.default.add(0|this.Dh,0|this.Dl,0|l,0|y)),({h:w,l:g}=i.default.add(0|this.Eh,0|this.El,0|w,0|g)),({h:p,l:b}=i.default.add(0|this.Fh,0|this.Fl,0|p,0|b)),({h:x,l:E}=i.default.add(0|this.Gh,0|this.Gl,0|x,0|E)),({h:m,l:B}=i.default.add(0|this.Hh,0|this.Hl,0|m,0|B)),this.set(n,r,o,h,u,d,l,y,w,g,p,b,x,E,m,B)}roundClean(){c.fill(0),f.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}e.SHA512=SHA512;class SHA512_256 extends SHA512{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class SHA384 extends SHA512{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}e.sha512=(0,o.wrapConstructor)(()=>new SHA512),e.sha512_256=(0,o.wrapConstructor)(()=>new SHA512_256),e.sha384=(0,o.wrapConstructor)(()=>new SHA384)},791:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SHA2=void 0;const r=n(1334),i=n(443);class SHA2 extends i.Hash{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,i.createView)(this.buffer)}update(t){r.default.exists(this);const{view:e,buffer:n,blockLen:o}=this,s=(t=(0,i.toBytes)(t)).length;for(let r=0;r<s;){const a=Math.min(o-this.pos,s-r);if(a!==o)n.set(t.subarray(r,r+a),this.pos),this.pos+=a,r+=a,this.pos===o&&(this.process(e,0),this.pos=0);else{const e=(0,i.createView)(t);for(;o<=s-r;r+=o)this.process(e,r)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){r.default.exists(this),r.default.output(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:o,isLE:s}=this;let{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>o-a&&(this.process(n,0),a=0);for(let t=a;t<o;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const i=BigInt(32),o=BigInt(4294967295),s=Number(n>>i&o),a=Number(n&o),c=r?4:0,f=r?0:4;t.setUint32(e+c,s,r),t.setUint32(e+f,a,r)}(n,o-8,BigInt(8*this.length),s),this.process(n,0);const c=(0,i.createView)(t);this.get().forEach((t,e)=>c.setUint32(4*e,t,s))}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:i,destroyed:o,pos:s}=this;return t.length=r,t.pos=s,t.finished=i,t.destroyed=o,r%e&&t.buffer.set(n),t}}e.SHA2=SHA2},876:function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=void 0;const r=n(1334),i=n(443);class HMAC extends i.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,r.default.hash(t);const n=(0,i.toBytes)(e);if(this.iHash=t.create(),!(this.iHash instanceof i.Hash))throw new TypeError("Expected instance of class which extends utils.Hash");const o=this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const s=new Uint8Array(o);s.set(n.length>this.iHash.blockLen?t.create().update(n).digest():n);for(let t=0;t<s.length;t++)s[t]^=54;this.iHash.update(s),this.oHash=t.create();for(let t=0;t<s.length;t++)s[t]^=106;this.oHash.update(s),s.fill(0)}update(t){return r.default.exists(this),this.iHash.update(t),this}digestInto(t){r.default.exists(this),r.default.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:i,blockLen:o,outputLen:s}=this;return(t=t).finished=r,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}e.hmac=(t,e,n)=>new HMAC(t,e).update(n).digest(),e.hmac.create=(t,e)=>new HMAC(t,e)}}]);