(window.webpackJsonp=window.webpackJsonp||[]).push([[304],{4247:function(t,e,r){"use strict";r.r(e);var s=r(1198),i=r(28),a=r.n(i),n=r(155),c=r(4),o=r(3),d=r(469),h=r(896);class HBARCoin extends(Object(d.g)(n.a)){constructor({alias:t,feeData:e,explorers:r,txWebUrl:s,socket:i}){super({alias:t,name:"Hedera",ticker:"HBAR",decimal:8,derivation:"m/44'/3030'/0'/0/0",unspendableBalance:"100000000",explorers:r,txWebUrl:s,socket:i}),this.fee=e.fee,this.transactions=[],this.fields.paymentId=!0,this.plugins=[new h.a]}async activationAccount(){if(!this.address)try{const{data:t}=await a.a.post("https://hedera-service.atomicwallet.io/account/",{publicKey:this.publicKey});this.address=t.accountId}catch(t){console.error(t)}return this.address}async loadWallet(t,e){const r=await s.Ed25519PrivateKey.fromMnemonic(e);if(!r)throw new c.i({type:o.x,error:new Error("can't get a privateKey!"),instance:this});return this.privateKey=r.toString(),this.publicKey=r.publicKey.toString(),this.address||a.a.get("https://hedera-service.atomicwallet.io/account/"+this.publicKey).then(({data:t})=>{this.address=t.accountId,this.account=this.getAddressStringFromAccountID(t.accountId)}).catch(t=>{console.error(t)}),this}getAddress(){if(this.address&&this.privateKey)return this.address;throw new c.i({type:o.x,error:new Error("address or privateKey is empty!"),instance:this})}async getAddressByPublicKey(t=null){if(!t&&!this.publicKey)throw new c.i({type:o.x,error:new Error("PublicKey is empty"),instance:this});t||(t=this.publicKey);try{const{accountId:t}=await a.a.get("https://hedera-service.atomicwallet.io/account/"+this.publicKey);return t}catch(t){return null}}getAddressStringFromAccountID(t){return s.AccountId.fromString(t).toString()}validateAddress(t){try{return s.AccountId.fromString(t).account>0}catch(t){return!1}}getClient(){if(!this.client){const t=this.getProvider("send");this.client=new s.Client({network:t.node,operator:{account:this.address,privateKey:this.privateKey}})}return this.client}async signTransaction(t){const e=this.getClient();return t.build(e)}async createTransaction({address:t,amount:e,memo:r}){const i=(new s.CryptoTransferTransaction).addSender(this.address,s.Hbar.fromTinybar(e)).addRecipient(t,s.Hbar.fromTinybar(e));r&&i.setTransactionMemo(r);const a=await this.signTransaction(i);return{rawtx:Buffer.from(a.toBytes()).toString("hex"),account:this.address,privateKey:this.privateKey}}async sendTransaction(t){return this.getProvider("send").sendTransaction(t)}async createAccountTransaction(t,e){const r=s.Ed25519PublicKey.fromString(t),i=(new s.AccountCreateTransaction).setKey(r).setInitialBalance(s.Hbar.fromTinybar(e)),a=await this.signTransaction(i);return Buffer.from(a.toBytes()).toString("hex")}async getInfo(){const{balance:t}=await this.getProvider("balance").getInfo(this.address);return this.balance=t,{balance:t}}async getTransactions(){if(!this.address)throw new Error("HBAR: getTransactions error: address is not loaded");return await this.getProvider("history").getTransactions({address:this.address})}setPrivateKey(t){this.privateKey=t,this.publicKey=s.Ed25519PrivateKey.fromString(t).publicKey.toString()}get instance(){return{id:this.id,ticker:this.ticker,name:this.name,alias:this.alias,assetName:this.assetName,decimal:this.decimal,privateKey:this.privateKey,account:this.address,getClient:()=>this.getClient()}}}e.default=HBARCoin}}]);